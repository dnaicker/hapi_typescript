/* eslint-disable */
import _m0 from "protobufjs/minimal";
function createBaseCreateOberonKeyRequest() {
    return { seed: new Uint8Array() };
}
export const CreateOberonKeyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.seed.length !== 0) {
            writer.uint32(10).bytes(message.seed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            seed: isSet(object.seed)
                ? bytesFromBase64(object.seed)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.seed !== undefined &&
            (obj.seed = base64FromBytes(message.seed !== undefined ? message.seed : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCreateOberonKeyRequest();
        message.seed = (_a = object.seed) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseCreateOberonKeyResponse() {
    return { sk: new Uint8Array(), pk: new Uint8Array() };
}
export const CreateOberonKeyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sk.length !== 0) {
            writer.uint32(18).bytes(message.sk);
        }
        if (message.pk.length !== 0) {
            writer.uint32(26).bytes(message.pk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonKeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.sk = reader.bytes();
                    break;
                case 3:
                    message.pk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sk: isSet(object.sk) ? bytesFromBase64(object.sk) : new Uint8Array(),
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.sk !== undefined &&
            (obj.sk = base64FromBytes(message.sk !== undefined ? message.sk : new Uint8Array()));
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCreateOberonKeyResponse();
        message.sk = (_a = object.sk) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pk = (_b = object.pk) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseCreateOberonTokenRequest() {
    return { sk: new Uint8Array(), data: new Uint8Array(), blinding: [] };
}
export const CreateOberonTokenRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sk.length !== 0) {
            writer.uint32(10).bytes(message.sk);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        for (const v of message.blinding) {
            writer.uint32(26).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sk = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.blinding.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sk: isSet(object.sk) ? bytesFromBase64(object.sk) : new Uint8Array(),
            data: isSet(object.data)
                ? bytesFromBase64(object.data)
                : new Uint8Array(),
            blinding: Array.isArray(object === null || object === void 0 ? void 0 : object.blinding)
                ? object.blinding.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.sk !== undefined &&
            (obj.sk = base64FromBytes(message.sk !== undefined ? message.sk : new Uint8Array()));
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        if (message.blinding) {
            obj.blinding = message.blinding.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.blinding = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCreateOberonTokenRequest();
        message.sk = (_a = object.sk) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.blinding = ((_c = object.blinding) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
function createBaseCreateOberonTokenResponse() {
    return { token: new Uint8Array() };
}
export const CreateOberonTokenResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCreateOberonTokenResponse();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseCreateOberonProofRequest() {
    return {
        data: new Uint8Array(),
        token: new Uint8Array(),
        blinding: [],
        nonce: new Uint8Array(),
    };
}
export const CreateOberonProofRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        if (message.token.length !== 0) {
            writer.uint32(18).bytes(message.token);
        }
        for (const v of message.blinding) {
            writer.uint32(26).bytes(v);
        }
        if (message.nonce.length !== 0) {
            writer.uint32(34).bytes(message.nonce);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonProofRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.token = reader.bytes();
                    break;
                case 3:
                    message.blinding.push(reader.bytes());
                    break;
                case 4:
                    message.nonce = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isSet(object.data)
                ? bytesFromBase64(object.data)
                : new Uint8Array(),
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
            blinding: Array.isArray(object === null || object === void 0 ? void 0 : object.blinding)
                ? object.blinding.map((e) => bytesFromBase64(e))
                : [],
            nonce: isSet(object.nonce)
                ? bytesFromBase64(object.nonce)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        if (message.blinding) {
            obj.blinding = message.blinding.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.blinding = [];
        }
        message.nonce !== undefined &&
            (obj.nonce = base64FromBytes(message.nonce !== undefined ? message.nonce : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseCreateOberonProofRequest();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.token = (_b = object.token) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.blinding = ((_c = object.blinding) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.nonce = (_d = object.nonce) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    },
};
function createBaseCreateOberonProofResponse() {
    return { proof: new Uint8Array() };
}
export const CreateOberonProofResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proof.length !== 0) {
            writer.uint32(18).bytes(message.proof);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateOberonProofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.proof = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            proof: isSet(object.proof)
                ? bytesFromBase64(object.proof)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.proof !== undefined &&
            (obj.proof = base64FromBytes(message.proof !== undefined ? message.proof : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCreateOberonProofResponse();
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseVerifyOberonProofRequest() {
    return {
        proof: new Uint8Array(),
        data: new Uint8Array(),
        nonce: new Uint8Array(),
        pk: new Uint8Array(),
    };
}
export const VerifyOberonProofRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proof.length !== 0) {
            writer.uint32(10).bytes(message.proof);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.nonce.length !== 0) {
            writer.uint32(26).bytes(message.nonce);
        }
        if (message.pk.length !== 0) {
            writer.uint32(34).bytes(message.pk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyOberonProofRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.proof = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.nonce = reader.bytes();
                    break;
                case 4:
                    message.pk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            proof: isSet(object.proof)
                ? bytesFromBase64(object.proof)
                : new Uint8Array(),
            data: isSet(object.data)
                ? bytesFromBase64(object.data)
                : new Uint8Array(),
            nonce: isSet(object.nonce)
                ? bytesFromBase64(object.nonce)
                : new Uint8Array(),
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.proof !== undefined &&
            (obj.proof = base64FromBytes(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.nonce !== undefined &&
            (obj.nonce = base64FromBytes(message.nonce !== undefined ? message.nonce : new Uint8Array()));
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseVerifyOberonProofRequest();
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.nonce = (_c = object.nonce) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.pk = (_d = object.pk) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    },
};
function createBaseVerifyOberonProofResponse() {
    return { valid: false };
}
export const VerifyOberonProofResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.valid === true) {
            writer.uint32(8).bool(message.valid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyOberonProofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            valid: isSet(object.valid) ? Boolean(object.valid) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.valid !== undefined && (obj.valid = message.valid);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifyOberonProofResponse();
        message.valid = (_a = object.valid) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBaseBlindOberonTokenRequest() {
    return { token: new Uint8Array(), blinding: [] };
}
export const BlindOberonTokenRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        for (const v of message.blinding) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlindOberonTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.blinding.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
            blinding: Array.isArray(object === null || object === void 0 ? void 0 : object.blinding)
                ? object.blinding.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        if (message.blinding) {
            obj.blinding = message.blinding.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.blinding = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBlindOberonTokenRequest();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.blinding = ((_b = object.blinding) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseBlindOberonTokenResponse() {
    return { token: new Uint8Array() };
}
export const BlindOberonTokenResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlindOberonTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBlindOberonTokenResponse();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseUnBlindOberonTokenRequest() {
    return { token: new Uint8Array(), blinding: [] };
}
export const UnBlindOberonTokenRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        for (const v of message.blinding) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnBlindOberonTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.blinding.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
            blinding: Array.isArray(object === null || object === void 0 ? void 0 : object.blinding)
                ? object.blinding.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        if (message.blinding) {
            obj.blinding = message.blinding.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.blinding = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUnBlindOberonTokenRequest();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.blinding = ((_b = object.blinding) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseUnBlindOberonTokenResponse() {
    return { token: new Uint8Array() };
}
export const UnBlindOberonTokenResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnBlindOberonTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUnBlindOberonTokenResponse();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseVerifyOberonTokenRequest() {
    return {
        token: new Uint8Array(),
        pk: new Uint8Array(),
        data: new Uint8Array(),
    };
}
export const VerifyOberonTokenRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token.length !== 0) {
            writer.uint32(10).bytes(message.token);
        }
        if (message.pk.length !== 0) {
            writer.uint32(18).bytes(message.pk);
        }
        if (message.data.length !== 0) {
            writer.uint32(26).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyOberonTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                case 2:
                    message.pk = reader.bytes();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? bytesFromBase64(object.token)
                : new Uint8Array(),
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
            data: isSet(object.data)
                ? bytesFromBase64(object.data)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = base64FromBytes(message.token !== undefined ? message.token : new Uint8Array()));
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseVerifyOberonTokenRequest();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pk = (_b = object.pk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    },
};
function createBaseVerifyOberonTokenResponse() {
    return { valid: false };
}
export const VerifyOberonTokenResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.valid === true) {
            writer.uint32(8).bool(message.valid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyOberonTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            valid: isSet(object.valid) ? Boolean(object.valid) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.valid !== undefined && (obj.valid = message.valid);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifyOberonTokenResponse();
        message.valid = (_a = object.valid) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(""));
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=security.js.map