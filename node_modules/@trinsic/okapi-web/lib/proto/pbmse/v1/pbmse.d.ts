import _m0 from "protobufjs/minimal";
export declare enum EncryptionMode {
    ENCRYPTION_MODE_UNSPECIFIED = 0,
    ENCRYPTION_MODE_DIRECT = 1,
    ENCRYPTION_MODE_CONTENT_ENCRYPTION_KEY = 2,
    UNRECOGNIZED = -1
}
export declare function encryptionModeFromJSON(object: any): EncryptionMode;
export declare function encryptionModeToJSON(object: EncryptionMode): string;
export declare enum EncryptionAlgorithm {
    ENCRYPTION_ALGORITHM_UNSPECIFIED = 0,
    ENCRYPTION_ALGORITHM_XCHACHA20POLY1305 = 1,
    ENCRYPTION_ALGORITHM_AES_GCM = 2,
    UNRECOGNIZED = -1
}
export declare function encryptionAlgorithmFromJSON(object: any): EncryptionAlgorithm;
export declare function encryptionAlgorithmToJSON(object: EncryptionAlgorithm): string;
/**
 * JWS
 * Protocol buffer message signing and encryption
 */
export interface SignedMessage {
    payload: Uint8Array;
    signatures: Signature[];
}
export interface Signature {
    header: Uint8Array;
    signature: Uint8Array;
}
export interface SignatureHeader {
    algorithm: string;
    keyId: string;
}
export interface EncryptedMessage {
    iv: Uint8Array;
    aad: Uint8Array;
    ciphertext: Uint8Array;
    tag: Uint8Array;
    recipients: EncryptionRecipient[];
}
export interface EncryptionHeader {
    mode: EncryptionMode;
    algorithm: EncryptionAlgorithm;
    keyId: string;
    senderKeyId: string;
}
export interface EncryptionRecipient {
    header: EncryptionHeader | undefined;
    contentEncryptionKey: Uint8Array;
}
export declare const SignedMessage: {
    encode(message: SignedMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedMessage;
    fromJSON(object: any): SignedMessage;
    toJSON(message: SignedMessage): unknown;
    fromPartial(object: DeepPartial<SignedMessage>): SignedMessage;
};
export declare const Signature: {
    encode(message: Signature, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Signature;
    fromJSON(object: any): Signature;
    toJSON(message: Signature): unknown;
    fromPartial(object: DeepPartial<Signature>): Signature;
};
export declare const SignatureHeader: {
    encode(message: SignatureHeader, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignatureHeader;
    fromJSON(object: any): SignatureHeader;
    toJSON(message: SignatureHeader): unknown;
    fromPartial(object: DeepPartial<SignatureHeader>): SignatureHeader;
};
export declare const EncryptedMessage: {
    encode(message: EncryptedMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EncryptedMessage;
    fromJSON(object: any): EncryptedMessage;
    toJSON(message: EncryptedMessage): unknown;
    fromPartial(object: DeepPartial<EncryptedMessage>): EncryptedMessage;
};
export declare const EncryptionHeader: {
    encode(message: EncryptionHeader, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EncryptionHeader;
    fromJSON(object: any): EncryptionHeader;
    toJSON(message: EncryptionHeader): unknown;
    fromPartial(object: DeepPartial<EncryptionHeader>): EncryptionHeader;
};
export declare const EncryptionRecipient: {
    encode(message: EncryptionRecipient, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EncryptionRecipient;
    fromJSON(object: any): EncryptionRecipient;
    toJSON(message: EncryptionRecipient): unknown;
    fromPartial(object: DeepPartial<EncryptionRecipient>): EncryptionRecipient;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
