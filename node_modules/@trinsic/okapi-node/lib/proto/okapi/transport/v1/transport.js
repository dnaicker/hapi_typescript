"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreMessage = exports.UnpackResponse = exports.UnpackRequest = exports.PackResponse = exports.PackRequest = exports.VerifyResponse = exports.VerifyRequest = exports.SignResponse = exports.SignRequest = void 0;
/* eslint-disable */
const pbmse_1 = require("../../../pbmse/v1/pbmse");
const long_1 = __importDefault(require("long"));
const keys_1 = require("../../keys/v1/keys");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
function createBaseSignRequest() {
    return { payload: new Uint8Array(), key: undefined, appendTo: undefined };
}
exports.SignRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.payload.length !== 0) {
            writer.uint32(10).bytes(message.payload);
        }
        if (message.key !== undefined) {
            keys_1.JsonWebKey.encode(message.key, writer.uint32(18).fork()).ldelim();
        }
        if (message.appendTo !== undefined) {
            pbmse_1.SignedMessage.encode(message.appendTo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.key = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.appendTo = pbmse_1.SignedMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            payload: isSet(object.payload)
                ? bytesFromBase64(object.payload)
                : new Uint8Array(),
            key: isSet(object.key) ? keys_1.JsonWebKey.fromJSON(object.key) : undefined,
            appendTo: isSet(object.appendTo)
                ? pbmse_1.SignedMessage.fromJSON(object.appendTo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.key !== undefined &&
            (obj.key = message.key ? keys_1.JsonWebKey.toJSON(message.key) : undefined);
        message.appendTo !== undefined &&
            (obj.appendTo = message.appendTo
                ? pbmse_1.SignedMessage.toJSON(message.appendTo)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSignRequest();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.key =
            object.key !== undefined && object.key !== null
                ? keys_1.JsonWebKey.fromPartial(object.key)
                : undefined;
        message.appendTo =
            object.appendTo !== undefined && object.appendTo !== null
                ? pbmse_1.SignedMessage.fromPartial(object.appendTo)
                : undefined;
        return message;
    },
};
function createBaseSignResponse() {
    return { message: undefined };
}
exports.SignResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== undefined) {
            pbmse_1.SignedMessage.encode(message.message, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = pbmse_1.SignedMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.message)
                ? pbmse_1.SignedMessage.fromJSON(object.message)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined &&
            (obj.message = message.message
                ? pbmse_1.SignedMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSignResponse();
        message.message =
            object.message !== undefined && object.message !== null
                ? pbmse_1.SignedMessage.fromPartial(object.message)
                : undefined;
        return message;
    },
};
function createBaseVerifyRequest() {
    return { message: undefined, key: undefined };
}
exports.VerifyRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== undefined) {
            pbmse_1.SignedMessage.encode(message.message, writer.uint32(10).fork()).ldelim();
        }
        if (message.key !== undefined) {
            keys_1.JsonWebKey.encode(message.key, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = pbmse_1.SignedMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.key = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.message)
                ? pbmse_1.SignedMessage.fromJSON(object.message)
                : undefined,
            key: isSet(object.key) ? keys_1.JsonWebKey.fromJSON(object.key) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined &&
            (obj.message = message.message
                ? pbmse_1.SignedMessage.toJSON(message.message)
                : undefined);
        message.key !== undefined &&
            (obj.key = message.key ? keys_1.JsonWebKey.toJSON(message.key) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseVerifyRequest();
        message.message =
            object.message !== undefined && object.message !== null
                ? pbmse_1.SignedMessage.fromPartial(object.message)
                : undefined;
        message.key =
            object.key !== undefined && object.key !== null
                ? keys_1.JsonWebKey.fromPartial(object.key)
                : undefined;
        return message;
    },
};
function createBaseVerifyResponse() {
    return { isValid: false };
}
exports.VerifyResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isValid === true) {
            writer.uint32(8).bool(message.isValid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isValid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.isValid !== undefined && (obj.isValid = message.isValid);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifyResponse();
        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBasePackRequest() {
    return {
        senderKey: undefined,
        receiverKey: undefined,
        associatedData: new Uint8Array(),
        plaintext: new Uint8Array(),
        mode: 0,
        algorithm: 0,
    };
}
exports.PackRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderKey !== undefined) {
            keys_1.JsonWebKey.encode(message.senderKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.receiverKey !== undefined) {
            keys_1.JsonWebKey.encode(message.receiverKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.associatedData.length !== 0) {
            writer.uint32(26).bytes(message.associatedData);
        }
        if (message.plaintext.length !== 0) {
            writer.uint32(34).bytes(message.plaintext);
        }
        if (message.mode !== 0) {
            writer.uint32(40).int32(message.mode);
        }
        if (message.algorithm !== 0) {
            writer.uint32(48).int32(message.algorithm);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePackRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderKey = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.receiverKey = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.associatedData = reader.bytes();
                    break;
                case 4:
                    message.plaintext = reader.bytes();
                    break;
                case 5:
                    message.mode = reader.int32();
                    break;
                case 6:
                    message.algorithm = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            senderKey: isSet(object.senderKey)
                ? keys_1.JsonWebKey.fromJSON(object.senderKey)
                : undefined,
            receiverKey: isSet(object.receiverKey)
                ? keys_1.JsonWebKey.fromJSON(object.receiverKey)
                : undefined,
            associatedData: isSet(object.associatedData)
                ? bytesFromBase64(object.associatedData)
                : new Uint8Array(),
            plaintext: isSet(object.plaintext)
                ? bytesFromBase64(object.plaintext)
                : new Uint8Array(),
            mode: isSet(object.mode) ? (0, pbmse_1.encryptionModeFromJSON)(object.mode) : 0,
            algorithm: isSet(object.algorithm)
                ? (0, pbmse_1.encryptionAlgorithmFromJSON)(object.algorithm)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.senderKey !== undefined &&
            (obj.senderKey = message.senderKey
                ? keys_1.JsonWebKey.toJSON(message.senderKey)
                : undefined);
        message.receiverKey !== undefined &&
            (obj.receiverKey = message.receiverKey
                ? keys_1.JsonWebKey.toJSON(message.receiverKey)
                : undefined);
        message.associatedData !== undefined &&
            (obj.associatedData = base64FromBytes(message.associatedData !== undefined
                ? message.associatedData
                : new Uint8Array()));
        message.plaintext !== undefined &&
            (obj.plaintext = base64FromBytes(message.plaintext !== undefined ? message.plaintext : new Uint8Array()));
        message.mode !== undefined &&
            (obj.mode = (0, pbmse_1.encryptionModeToJSON)(message.mode));
        message.algorithm !== undefined &&
            (obj.algorithm = (0, pbmse_1.encryptionAlgorithmToJSON)(message.algorithm));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBasePackRequest();
        message.senderKey =
            object.senderKey !== undefined && object.senderKey !== null
                ? keys_1.JsonWebKey.fromPartial(object.senderKey)
                : undefined;
        message.receiverKey =
            object.receiverKey !== undefined && object.receiverKey !== null
                ? keys_1.JsonWebKey.fromPartial(object.receiverKey)
                : undefined;
        message.associatedData = (_a = object.associatedData) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.plaintext = (_b = object.plaintext) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.mode = (_c = object.mode) !== null && _c !== void 0 ? _c : 0;
        message.algorithm = (_d = object.algorithm) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
function createBasePackResponse() {
    return { message: undefined };
}
exports.PackResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== undefined) {
            pbmse_1.EncryptedMessage.encode(message.message, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePackResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = pbmse_1.EncryptedMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.message)
                ? pbmse_1.EncryptedMessage.fromJSON(object.message)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined &&
            (obj.message = message.message
                ? pbmse_1.EncryptedMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePackResponse();
        message.message =
            object.message !== undefined && object.message !== null
                ? pbmse_1.EncryptedMessage.fromPartial(object.message)
                : undefined;
        return message;
    },
};
function createBaseUnpackRequest() {
    return { senderKey: undefined, receiverKey: undefined, message: undefined };
}
exports.UnpackRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderKey !== undefined) {
            keys_1.JsonWebKey.encode(message.senderKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.receiverKey !== undefined) {
            keys_1.JsonWebKey.encode(message.receiverKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.message !== undefined) {
            pbmse_1.EncryptedMessage.encode(message.message, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnpackRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderKey = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.receiverKey = keys_1.JsonWebKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.message = pbmse_1.EncryptedMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            senderKey: isSet(object.senderKey)
                ? keys_1.JsonWebKey.fromJSON(object.senderKey)
                : undefined,
            receiverKey: isSet(object.receiverKey)
                ? keys_1.JsonWebKey.fromJSON(object.receiverKey)
                : undefined,
            message: isSet(object.message)
                ? pbmse_1.EncryptedMessage.fromJSON(object.message)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.senderKey !== undefined &&
            (obj.senderKey = message.senderKey
                ? keys_1.JsonWebKey.toJSON(message.senderKey)
                : undefined);
        message.receiverKey !== undefined &&
            (obj.receiverKey = message.receiverKey
                ? keys_1.JsonWebKey.toJSON(message.receiverKey)
                : undefined);
        message.message !== undefined &&
            (obj.message = message.message
                ? pbmse_1.EncryptedMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUnpackRequest();
        message.senderKey =
            object.senderKey !== undefined && object.senderKey !== null
                ? keys_1.JsonWebKey.fromPartial(object.senderKey)
                : undefined;
        message.receiverKey =
            object.receiverKey !== undefined && object.receiverKey !== null
                ? keys_1.JsonWebKey.fromPartial(object.receiverKey)
                : undefined;
        message.message =
            object.message !== undefined && object.message !== null
                ? pbmse_1.EncryptedMessage.fromPartial(object.message)
                : undefined;
        return message;
    },
};
function createBaseUnpackResponse() {
    return { plaintext: new Uint8Array() };
}
exports.UnpackResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.plaintext.length !== 0) {
            writer.uint32(10).bytes(message.plaintext);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnpackResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.plaintext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            plaintext: isSet(object.plaintext)
                ? bytesFromBase64(object.plaintext)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.plaintext !== undefined &&
            (obj.plaintext = base64FromBytes(message.plaintext !== undefined ? message.plaintext : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUnpackResponse();
        message.plaintext = (_a = object.plaintext) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseCoreMessage() {
    return {
        id: "",
        type: "",
        body: new Uint8Array(),
        to: [],
        from: "",
        created: 0,
        expires: 0,
    };
}
exports.CoreMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.body.length !== 0) {
            writer.uint32(26).bytes(message.body);
        }
        for (const v of message.to) {
            writer.uint32(34).string(v);
        }
        if (message.from !== "") {
            writer.uint32(42).string(message.from);
        }
        if (message.created !== 0) {
            writer.uint32(48).int64(message.created);
        }
        if (message.expires !== 0) {
            writer.uint32(56).int64(message.expires);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoreMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.string();
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                case 4:
                    message.to.push(reader.string());
                    break;
                case 5:
                    message.from = reader.string();
                    break;
                case 6:
                    message.created = longToNumber(reader.int64());
                    break;
                case 7:
                    message.expires = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            type: isSet(object.type) ? String(object.type) : "",
            body: isSet(object.body)
                ? bytesFromBase64(object.body)
                : new Uint8Array(),
            to: Array.isArray(object === null || object === void 0 ? void 0 : object.to) ? object.to.map((e) => String(e)) : [],
            from: isSet(object.from) ? String(object.from) : "",
            created: isSet(object.created_time) ? Number(object.created_time) : 0,
            expires: isSet(object.expires_time) ? Number(object.expires_time) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.type !== undefined && (obj.type = message.type);
        message.body !== undefined &&
            (obj.body = base64FromBytes(message.body !== undefined ? message.body : new Uint8Array()));
        if (message.to) {
            obj.to = message.to.map((e) => e);
        }
        else {
            obj.to = [];
        }
        message.from !== undefined && (obj.from = message.from);
        message.created !== undefined &&
            (obj.created_time = Math.round(message.created));
        message.expires !== undefined &&
            (obj.expires_time = Math.round(message.expires));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseCoreMessage();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : "";
        message.body = (_c = object.body) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.to = ((_d = object.to) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.from = (_e = object.from) !== null && _e !== void 0 ? _e : "";
        message.created = (_f = object.created) !== null && _f !== void 0 ? _f : 0;
        message.expires = (_g = object.expires) !== null && _g !== void 0 ? _g : 0;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(""));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=transport.js.map