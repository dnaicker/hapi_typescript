"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonWebKey = exports.ResolveResponse = exports.ResolveRequest = exports.GenerateKeyResponse = exports.GenerateKeyRequest = exports.documentKeyFormatToJSON = exports.documentKeyFormatFromJSON = exports.DocumentKeyFormat = exports.keyTypeToJSON = exports.keyTypeFromJSON = exports.KeyType = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const struct_1 = require("../../../google/protobuf/struct");
var KeyType;
(function (KeyType) {
    KeyType[KeyType["KEY_TYPE_UNSPECIFIED"] = 0] = "KEY_TYPE_UNSPECIFIED";
    KeyType[KeyType["KEY_TYPE_ED25519"] = 1] = "KEY_TYPE_ED25519";
    KeyType[KeyType["KEY_TYPE_X25519"] = 2] = "KEY_TYPE_X25519";
    KeyType[KeyType["KEY_TYPE_P256"] = 3] = "KEY_TYPE_P256";
    KeyType[KeyType["KEY_TYPE_BLS12381G1G2"] = 4] = "KEY_TYPE_BLS12381G1G2";
    KeyType[KeyType["KEY_TYPE_SECP256K1"] = 5] = "KEY_TYPE_SECP256K1";
    KeyType[KeyType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
function keyTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "KEY_TYPE_UNSPECIFIED":
            return KeyType.KEY_TYPE_UNSPECIFIED;
        case 1:
        case "KEY_TYPE_ED25519":
            return KeyType.KEY_TYPE_ED25519;
        case 2:
        case "KEY_TYPE_X25519":
            return KeyType.KEY_TYPE_X25519;
        case 3:
        case "KEY_TYPE_P256":
            return KeyType.KEY_TYPE_P256;
        case 4:
        case "KEY_TYPE_BLS12381G1G2":
            return KeyType.KEY_TYPE_BLS12381G1G2;
        case 5:
        case "KEY_TYPE_SECP256K1":
            return KeyType.KEY_TYPE_SECP256K1;
        case -1:
        case "UNRECOGNIZED":
        default:
            return KeyType.UNRECOGNIZED;
    }
}
exports.keyTypeFromJSON = keyTypeFromJSON;
function keyTypeToJSON(object) {
    switch (object) {
        case KeyType.KEY_TYPE_UNSPECIFIED:
            return "KEY_TYPE_UNSPECIFIED";
        case KeyType.KEY_TYPE_ED25519:
            return "KEY_TYPE_ED25519";
        case KeyType.KEY_TYPE_X25519:
            return "KEY_TYPE_X25519";
        case KeyType.KEY_TYPE_P256:
            return "KEY_TYPE_P256";
        case KeyType.KEY_TYPE_BLS12381G1G2:
            return "KEY_TYPE_BLS12381G1G2";
        case KeyType.KEY_TYPE_SECP256K1:
            return "KEY_TYPE_SECP256K1";
        case KeyType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.keyTypeToJSON = keyTypeToJSON;
var DocumentKeyFormat;
(function (DocumentKeyFormat) {
    DocumentKeyFormat[DocumentKeyFormat["DOCUMENT_KEY_FORMAT_UNSPECIFIED"] = 0] = "DOCUMENT_KEY_FORMAT_UNSPECIFIED";
    DocumentKeyFormat[DocumentKeyFormat["DOCUMENT_KEY_FORMAT_LD"] = 1] = "DOCUMENT_KEY_FORMAT_LD";
    DocumentKeyFormat[DocumentKeyFormat["DOCUMENT_KEY_FORMAT_JOSE"] = 2] = "DOCUMENT_KEY_FORMAT_JOSE";
    DocumentKeyFormat[DocumentKeyFormat["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DocumentKeyFormat = exports.DocumentKeyFormat || (exports.DocumentKeyFormat = {}));
function documentKeyFormatFromJSON(object) {
    switch (object) {
        case 0:
        case "DOCUMENT_KEY_FORMAT_UNSPECIFIED":
            return DocumentKeyFormat.DOCUMENT_KEY_FORMAT_UNSPECIFIED;
        case 1:
        case "DOCUMENT_KEY_FORMAT_LD":
            return DocumentKeyFormat.DOCUMENT_KEY_FORMAT_LD;
        case 2:
        case "DOCUMENT_KEY_FORMAT_JOSE":
            return DocumentKeyFormat.DOCUMENT_KEY_FORMAT_JOSE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DocumentKeyFormat.UNRECOGNIZED;
    }
}
exports.documentKeyFormatFromJSON = documentKeyFormatFromJSON;
function documentKeyFormatToJSON(object) {
    switch (object) {
        case DocumentKeyFormat.DOCUMENT_KEY_FORMAT_UNSPECIFIED:
            return "DOCUMENT_KEY_FORMAT_UNSPECIFIED";
        case DocumentKeyFormat.DOCUMENT_KEY_FORMAT_LD:
            return "DOCUMENT_KEY_FORMAT_LD";
        case DocumentKeyFormat.DOCUMENT_KEY_FORMAT_JOSE:
            return "DOCUMENT_KEY_FORMAT_JOSE";
        case DocumentKeyFormat.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.documentKeyFormatToJSON = documentKeyFormatToJSON;
function createBaseGenerateKeyRequest() {
    return { seed: new Uint8Array(), keyType: 0, keyFormat: 0 };
}
exports.GenerateKeyRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seed.length !== 0) {
            writer.uint32(10).bytes(message.seed);
        }
        if (message.keyType !== 0) {
            writer.uint32(16).int32(message.keyType);
        }
        if (message.keyFormat !== 0) {
            writer.uint32(24).int32(message.keyFormat);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seed = reader.bytes();
                    break;
                case 2:
                    message.keyType = reader.int32();
                    break;
                case 3:
                    message.keyFormat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            seed: isSet(object.seed)
                ? bytesFromBase64(object.seed)
                : new Uint8Array(),
            keyType: isSet(object.keyType) ? keyTypeFromJSON(object.keyType) : 0,
            keyFormat: isSet(object.keyFormat)
                ? documentKeyFormatFromJSON(object.keyFormat)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.seed !== undefined &&
            (obj.seed = base64FromBytes(message.seed !== undefined ? message.seed : new Uint8Array()));
        message.keyType !== undefined &&
            (obj.keyType = keyTypeToJSON(message.keyType));
        message.keyFormat !== undefined &&
            (obj.keyFormat = documentKeyFormatToJSON(message.keyFormat));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseGenerateKeyRequest();
        message.seed = (_a = object.seed) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.keyType = (_b = object.keyType) !== null && _b !== void 0 ? _b : 0;
        message.keyFormat = (_c = object.keyFormat) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseGenerateKeyResponse() {
    return { key: [], didDocument: undefined };
}
exports.GenerateKeyResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.key) {
            exports.JsonWebKey.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.didDocument !== undefined) {
            struct_1.Struct.encode(struct_1.Struct.wrap(message.didDocument), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateKeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key.push(exports.JsonWebKey.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.didDocument = struct_1.Struct.unwrap(struct_1.Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: Array.isArray(object === null || object === void 0 ? void 0 : object.key)
                ? object.key.map((e) => exports.JsonWebKey.fromJSON(e))
                : [],
            didDocument: isObject(object.didDocument)
                ? object.didDocument
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key) {
            obj.key = message.key.map((e) => (e ? exports.JsonWebKey.toJSON(e) : undefined));
        }
        else {
            obj.key = [];
        }
        message.didDocument !== undefined &&
            (obj.didDocument = message.didDocument);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGenerateKeyResponse();
        message.key = ((_a = object.key) === null || _a === void 0 ? void 0 : _a.map((e) => exports.JsonWebKey.fromPartial(e))) || [];
        message.didDocument = (_b = object.didDocument) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseResolveRequest() {
    return { did: "" };
}
exports.ResolveRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.did !== "") {
            writer.uint32(10).string(message.did);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResolveRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.did = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            did: isSet(object.did) ? String(object.did) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.did !== undefined && (obj.did = message.did);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseResolveRequest();
        message.did = (_a = object.did) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseResolveResponse() {
    return { didDocument: undefined, keys: [] };
}
exports.ResolveResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.didDocument !== undefined) {
            struct_1.Struct.encode(struct_1.Struct.wrap(message.didDocument), writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.keys) {
            exports.JsonWebKey.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResolveResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.didDocument = struct_1.Struct.unwrap(struct_1.Struct.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.keys.push(exports.JsonWebKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            didDocument: isObject(object.didDocument)
                ? object.didDocument
                : undefined,
            keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys)
                ? object.keys.map((e) => exports.JsonWebKey.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.didDocument !== undefined &&
            (obj.didDocument = message.didDocument);
        if (message.keys) {
            obj.keys = message.keys.map((e) => e ? exports.JsonWebKey.toJSON(e) : undefined);
        }
        else {
            obj.keys = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseResolveResponse();
        message.didDocument = (_a = object.didDocument) !== null && _a !== void 0 ? _a : undefined;
        message.keys = ((_b = object.keys) === null || _b === void 0 ? void 0 : _b.map((e) => exports.JsonWebKey.fromPartial(e))) || [];
        return message;
    },
};
function createBaseJsonWebKey() {
    return { kid: "", x: "", y: "", d: "", crv: "", kty: "" };
}
exports.JsonWebKey = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.kid !== "") {
            writer.uint32(10).string(message.kid);
        }
        if (message.x !== "") {
            writer.uint32(18).string(message.x);
        }
        if (message.y !== "") {
            writer.uint32(26).string(message.y);
        }
        if (message.d !== "") {
            writer.uint32(34).string(message.d);
        }
        if (message.crv !== "") {
            writer.uint32(42).string(message.crv);
        }
        if (message.kty !== "") {
            writer.uint32(50).string(message.kty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonWebKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kid = reader.string();
                    break;
                case 2:
                    message.x = reader.string();
                    break;
                case 3:
                    message.y = reader.string();
                    break;
                case 4:
                    message.d = reader.string();
                    break;
                case 5:
                    message.crv = reader.string();
                    break;
                case 6:
                    message.kty = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            kid: isSet(object.kid) ? String(object.kid) : "",
            x: isSet(object.x) ? String(object.x) : "",
            y: isSet(object.y) ? String(object.y) : "",
            d: isSet(object.d) ? String(object.d) : "",
            crv: isSet(object.crv) ? String(object.crv) : "",
            kty: isSet(object.kty) ? String(object.kty) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.kid !== undefined && (obj.kid = message.kid);
        message.x !== undefined && (obj.x = message.x);
        message.y !== undefined && (obj.y = message.y);
        message.d !== undefined && (obj.d = message.d);
        message.crv !== undefined && (obj.crv = message.crv);
        message.kty !== undefined && (obj.kty = message.kty);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseJsonWebKey();
        message.kid = (_a = object.kid) !== null && _a !== void 0 ? _a : "";
        message.x = (_b = object.x) !== null && _b !== void 0 ? _b : "";
        message.y = (_c = object.y) !== null && _c !== void 0 ? _c : "";
        message.d = (_d = object.d) !== null && _d !== void 0 ? _d : "";
        message.crv = (_e = object.crv) !== null && _e !== void 0 ? _e : "";
        message.kty = (_f = object.kty) !== null && _f !== void 0 ? _f : "";
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(""));
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=keys.js.map