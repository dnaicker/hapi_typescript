"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeProvider = void 0;
const okapi_node_1 = require("@trinsic/okapi-node");
const nice_grpc_1 = require("nice-grpc");
const nice_grpc_web_1 = require("nice-grpc-web");
const grpc_web_node_http_transport_1 = require("@improbable-eng/grpc-web-node-http-transport");
class NodeProvider {
    async blake3HashRequest(requestData) {
        let requestHash = new Uint8Array();
        if (requestData.length > 0) {
            let hashResponse = await okapi_node_1.Hashing.blake3Hash({ data: requestData });
            requestHash = hashResponse.digest;
        }
        return requestHash;
    }
    async blindOberon(cloned, securityCode) {
        let response = await okapi_node_1.Oberon.blindToken({
            token: cloned.authToken,
            blinding: [securityCode],
        });
        return response.token;
    }
    async oberonProofRequest(profile, nonceUint8) {
        let proof = await okapi_node_1.Oberon.createProof({
            data: profile.authData,
            nonce: nonceUint8,
            token: profile.authToken,
            blinding: [],
        });
        return proof.proof;
    }
    async okapiVersion() {
        return (await okapi_node_1.OkapiMetadata.getMetadata()).version;
    }
    async unblindOberon(cloned, securityCode) {
        let response = await okapi_node_1.Oberon.unblindToken({
            token: cloned.authToken,
            blinding: [securityCode],
        });
        return response.token;
    }
    createGrpcClient(definition, address) {
        if (NodeProvider.useHttp1) {
            return (0, nice_grpc_web_1.createClient)(definition, (0, nice_grpc_web_1.createChannel)(address, (0, grpc_web_node_http_transport_1.NodeHttpTransport)()));
        }
        // @ts-ignore - compatible types, duplicate definitions
        return (0, nice_grpc_1.createClient)(definition, (0, nice_grpc_1.createChannel)(address));
    }
    metadataLanguage() {
        if (NodeProvider.useHttp1)
            return "typescript-node-http1";
        return "typescript-node";
    }
}
exports.NodeProvider = NodeProvider;
NodeProvider.useHttp1 = false;
//# sourceMappingURL=NodeProvider.js.map