"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderService = void 0;
const ServiceBase_1 = __importDefault(require("./ServiceBase"));
const proto = __importStar(require("./proto"));
const js_base64_1 = require("js-base64");
class ProviderService extends ServiceBase_1.default {
    constructor(options) {
        super(options);
        this.client = this.createClient(proto.ProviderDefinition);
    }
    async createEcosystem(request) {
        var _a, _b, _c;
        const response = ((_a = request.name) === null || _a === void 0 ? void 0 : _a.trim()) || ((_c = (_b = request.details) === null || _b === void 0 ? void 0 : _b.email) === null || _c === void 0 ? void 0 : _c.trim())
            ? await this.client.createEcosystem(request, {
                metadata: await this.buildMetadata(proto.CreateEcosystemRequest.encode(request).finish()),
            })
            : await this.client.createEcosystem(request);
        const authToken = js_base64_1.Base64.fromUint8Array(proto.AccountProfile.encode(response.profile).finish(), true);
        this.options.authToken = authToken;
        return response;
    }
    // BEGIN Code generated by protoc-gen-trinsic. DO NOT EDIT.
    // target: /home/runner/work/sdk/sdk/web/src/ProviderService.ts
    /** Update an existing ecosystem */
    async updateEcosystem(request) {
        return this.client.updateEcosystem(request, {
            metadata: await this.buildMetadata(proto.UpdateEcosystemRequest.encode(request).finish())
        });
    }
    /** Grant user authorization to ecosystem resources */
    async grantAuthorization(request) {
        return this.client.grantAuthorization(request, {
            metadata: await this.buildMetadata(proto.GrantAuthorizationRequest.encode(request).finish())
        });
    }
    /** Revoke user authorization to ecosystem resources */
    async revokeAuthorization(request) {
        return this.client.revokeAuthorization(request, {
            metadata: await this.buildMetadata(proto.RevokeAuthorizationRequest.encode(request).finish())
        });
    }
    /** Retrieve the list of permissions for this particular account/ecosystem */
    async getAuthorizations(request) {
        return this.client.getAuthorizations(request, {
            metadata: await this.buildMetadata(proto.GetAuthorizationsRequest.encode(request).finish())
        });
    }
    /** Add a webhook endpoint to the ecosystem */
    async addWebhook(request) {
        return this.client.addWebhook(request, {
            metadata: await this.buildMetadata(proto.AddWebhookRequest.encode(request).finish())
        });
    }
    /** Delete a webhook endpoint from the ecosystem */
    async deleteWebhook(request) {
        return this.client.deleteWebhook(request, {
            metadata: await this.buildMetadata(proto.DeleteWebhookRequest.encode(request).finish())
        });
    }
    /** Get ecosystem information */
    async ecosystemInfo(request) {
        return this.client.ecosystemInfo(request, {
            metadata: await this.buildMetadata(proto.EcosystemInfoRequest.encode(request).finish())
        });
    }
    /** Get public ecosystem information about *any* ecosystem */
    async getPublicEcosystemInfo(request) {
        return this.client.getPublicEcosystemInfo(request, {
            metadata: await this.buildMetadata()
        });
    }
    /** Generates an unprotected authentication token that can be used to
  * configure server side applications */
    async generateToken(request) {
        return this.client.generateToken(request, {
            metadata: await this.buildMetadata(proto.GenerateTokenRequest.encode(request).finish())
        });
    }
    /** Invite a user to the ecosystem */
    async invite(request) {
        return this.client.invite(request, {
            metadata: await this.buildMetadata(proto.InviteRequest.encode(request).finish())
        });
    }
    /** Check the status of an invitation */
    async invitationStatus(request) {
        return this.client.invitationStatus(request, {
            metadata: await this.buildMetadata(proto.InvitationStatusRequest.encode(request).finish())
        });
    }
    /** Returns the public key being used to create/verify oberon tokens */
    async getOberonKey(request) {
        return this.client.getOberonKey(request, {
            metadata: await this.buildMetadata()
        });
    }
    /** Generate a signed token (JWT) that can be used to connect to the message bus */
    async getEventToken(request) {
        return this.client.getEventToken(request, {
            metadata: await this.buildMetadata(proto.GetEventTokenRequest.encode(request).finish())
        });
    }
    /** Upgrade a wallet's DID from `did:key` to another method */
    async upgradeDID(request) {
        return this.client.upgradeDID(request, {
            metadata: await this.buildMetadata(proto.UpgradeDidRequest.encode(request).finish())
        });
    }
    /** Retrieve a random hash TXT that can be used to verify domain ownership */
    async retrieveDomainVerificationRecord() {
        let request = proto.RetrieveDomainVerificationRecordRequest.fromPartial({});
        return this.client.retrieveDomainVerificationRecord(request, {
            metadata: await this.buildMetadata(proto.RetrieveDomainVerificationRecordRequest.encode(request).finish())
        });
    }
    /** Call to verify domain */
    async refreshDomainVerificationStatus(request) {
        return this.client.refreshDomainVerificationStatus(request, {
            metadata: await this.buildMetadata(proto.RefreshDomainVerificationStatusRequest.encode(request).finish())
        });
    }
    /** Search for issuers/providers/verifiers in the current ecosystem */
    async searchWalletConfigurations(request) {
        return this.client.searchWalletConfigurations(request, {
            metadata: await this.buildMetadata(proto.SearchWalletConfigurationsRequest.encode(request).finish())
        });
    }
}
exports.ProviderService = ProviderService;
//# sourceMappingURL=ProviderService.js.map