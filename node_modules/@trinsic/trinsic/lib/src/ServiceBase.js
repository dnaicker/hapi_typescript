"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const proto_1 = require("./proto");
const nice_grpc_common_1 = require("nice-grpc-common");
const js_base64_1 = require("js-base64");
const Version_1 = require("./Version");
const TokenProvider_1 = require("./TokenProvider");
class ServiceBase {
    constructor(options = proto_1.ServiceOptions.fromPartial({})) {
        this.tokenProvider = TokenProvider_1.MemoryTokenProvider.DefaultInstance();
        options.serverEndpoint = options.serverEndpoint || "prod.trinsic.cloud";
        options.serverPort = options.serverPort || 443;
        options.serverUseTls =
            options.serverPort == 443 ? true : options.serverUseTls || false;
        this.options = options;
    }
    static setProvider(provider) {
        ServiceBase.trinsicProvider = provider;
    }
    async buildMetadata(request) {
        var _a;
        const metadata = new nice_grpc_common_1.Metadata();
        metadata.append("trinsicokapiversion", await ServiceBase.trinsicProvider.okapiVersion());
        metadata.append("trinsicsdklanguage".toLowerCase(), ServiceBase.trinsicProvider.metadataLanguage());
        metadata.append("trinsicsdkversion".toLowerCase(), (0, Version_1.getSdkVersion)());
        if (request != undefined || request != null) {
            let authToken = this.options.authToken ||
                (await this.tokenProvider.getDefault());
            if (!authToken) {
                throw new Error("auth token must be set");
            }
            const profile = proto_1.AccountProfile.decode(js_base64_1.Base64.toUint8Array(authToken));
            if ((_a = profile.protection) === null || _a === void 0 ? void 0 : _a.enabled) {
                throw new Error("profile is protected; you must use security code to remove the protection first");
            }
            const requestHash = await ServiceBase.trinsicProvider.blake3HashRequest(request);
            const timestamp = Date.now();
            let nonce = {
                timestamp: timestamp,
                requestHash: requestHash,
            };
            const nonceUint8 = proto_1.Nonce.encode(nonce).finish();
            const proof = await ServiceBase.trinsicProvider.oberonProofRequest(profile, nonceUint8);
            metadata.append("authorization", `Oberon ` +
                `ver=1,` +
                `proof=${js_base64_1.Base64.fromUint8Array(proof, true)},` +
                `data=${js_base64_1.Base64.fromUint8Array(profile.authData, true)},` +
                `nonce=${js_base64_1.Base64.fromUint8Array(nonceUint8, true)}`);
        }
        return metadata;
    }
    setAuthToken(token) {
        this.options.authToken = token;
    }
    createClient(definition) {
        let address = `${this.options.serverUseTls ? "https" : "http"}://${this.options.serverEndpoint}:${this.options.serverPort}`;
        return ServiceBase.trinsicProvider.createGrpcClient(definition, address);
    }
}
exports.default = ServiceBase;
//# sourceMappingURL=ServiceBase.js.map