"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchWalletConfigurationResponse = exports.SearchWalletConfigurationsRequest = exports.GetAuthorizationsResponse = exports.GetAuthorizationsRequest = exports.RevokeAuthorizationResponse = exports.RevokeAuthorizationRequest = exports.GrantAuthorizationResponse = exports.GrantAuthorizationRequest = exports.RefreshDomainVerificationStatusResponse = exports.RefreshDomainVerificationStatusRequest = exports.RetrieveDomainVerificationRecordResponse = exports.RetrieveDomainVerificationRecordRequest = exports.GetEventTokenResponse = exports.GetEventTokenRequest = exports.GetOberonKeyResponse = exports.GetOberonKeyRequest = exports.GenerateTokenResponse = exports.GenerateTokenRequest = exports.PublicEcosystemInformation = exports.GetPublicEcosystemInfoResponse = exports.GetPublicEcosystemInfoRequest = exports.EcosystemInfoResponse = exports.EcosystemInfoRequest = exports.DeleteWebhookResponse = exports.DeleteWebhookRequest = exports.AddWebhookResponse = exports.AddWebhookRequest = exports.UpdateEcosystemResponse = exports.EcosystemDisplayDetails = exports.EcosystemDisplay = exports.UpdateEcosystemRequest = exports.CreateEcosystemResponse = exports.CreateEcosystemRequest = exports.Grant = exports.WebhookConfig = exports.Ecosystem = exports.InvitationStatusResponse = exports.InvitationStatusRequest = exports.InviteResponse = exports.InviteRequest_DidCommInvitation = exports.InviteRequest = exports.ionOptions_IonNetworkToJSON = exports.ionOptions_IonNetworkFromJSON = exports.IonOptions_IonNetwork = exports.invitationStatusResponse_StatusToJSON = exports.invitationStatusResponse_StatusFromJSON = exports.InvitationStatusResponse_Status = exports.participantTypeToJSON = exports.participantTypeFromJSON = exports.ParticipantType = void 0;
exports.ProviderDefinition = exports.UpgradeDidResponse = exports.UpgradeDidRequest = exports.IonOptions = exports.WalletConfiguration = void 0;
/* eslint-disable */
const account_1 = require("../../account/v1/account");
const common_1 = require("../../common/v1/common");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
/** Type of participant being invited to ecosystem */
var ParticipantType;
(function (ParticipantType) {
    /** participant_type_individual - Participant is an individual */
    ParticipantType[ParticipantType["participant_type_individual"] = 0] = "participant_type_individual";
    /** participant_type_organization - Participant is an organization */
    ParticipantType[ParticipantType["participant_type_organization"] = 1] = "participant_type_organization";
    ParticipantType[ParticipantType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ParticipantType = exports.ParticipantType || (exports.ParticipantType = {}));
function participantTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "participant_type_individual":
            return ParticipantType.participant_type_individual;
        case 1:
        case "participant_type_organization":
            return ParticipantType.participant_type_organization;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ParticipantType.UNRECOGNIZED;
    }
}
exports.participantTypeFromJSON = participantTypeFromJSON;
function participantTypeToJSON(object) {
    switch (object) {
        case ParticipantType.participant_type_individual:
            return "participant_type_individual";
        case ParticipantType.participant_type_organization:
            return "participant_type_organization";
        case ParticipantType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.participantTypeToJSON = participantTypeToJSON;
var InvitationStatusResponse_Status;
(function (InvitationStatusResponse_Status) {
    /** Error - Onboarding resulted in error */
    InvitationStatusResponse_Status[InvitationStatusResponse_Status["Error"] = 0] = "Error";
    /** InvitationSent - The participant has been invited */
    InvitationStatusResponse_Status[InvitationStatusResponse_Status["InvitationSent"] = 1] = "InvitationSent";
    /** Completed - The participant has been onboarded */
    InvitationStatusResponse_Status[InvitationStatusResponse_Status["Completed"] = 2] = "Completed";
    /** Expired - The invite has expired */
    InvitationStatusResponse_Status[InvitationStatusResponse_Status["Expired"] = 3] = "Expired";
    InvitationStatusResponse_Status[InvitationStatusResponse_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InvitationStatusResponse_Status = exports.InvitationStatusResponse_Status || (exports.InvitationStatusResponse_Status = {}));
function invitationStatusResponse_StatusFromJSON(object) {
    switch (object) {
        case 0:
        case "Error":
            return InvitationStatusResponse_Status.Error;
        case 1:
        case "InvitationSent":
            return InvitationStatusResponse_Status.InvitationSent;
        case 2:
        case "Completed":
            return InvitationStatusResponse_Status.Completed;
        case 3:
        case "Expired":
            return InvitationStatusResponse_Status.Expired;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InvitationStatusResponse_Status.UNRECOGNIZED;
    }
}
exports.invitationStatusResponse_StatusFromJSON = invitationStatusResponse_StatusFromJSON;
function invitationStatusResponse_StatusToJSON(object) {
    switch (object) {
        case InvitationStatusResponse_Status.Error:
            return "Error";
        case InvitationStatusResponse_Status.InvitationSent:
            return "InvitationSent";
        case InvitationStatusResponse_Status.Completed:
            return "Completed";
        case InvitationStatusResponse_Status.Expired:
            return "Expired";
        case InvitationStatusResponse_Status.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.invitationStatusResponse_StatusToJSON = invitationStatusResponse_StatusToJSON;
var IonOptions_IonNetwork;
(function (IonOptions_IonNetwork) {
    IonOptions_IonNetwork[IonOptions_IonNetwork["TestNet"] = 0] = "TestNet";
    IonOptions_IonNetwork[IonOptions_IonNetwork["MainNet"] = 1] = "MainNet";
    IonOptions_IonNetwork[IonOptions_IonNetwork["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(IonOptions_IonNetwork = exports.IonOptions_IonNetwork || (exports.IonOptions_IonNetwork = {}));
function ionOptions_IonNetworkFromJSON(object) {
    switch (object) {
        case 0:
        case "TestNet":
            return IonOptions_IonNetwork.TestNet;
        case 1:
        case "MainNet":
            return IonOptions_IonNetwork.MainNet;
        case -1:
        case "UNRECOGNIZED":
        default:
            return IonOptions_IonNetwork.UNRECOGNIZED;
    }
}
exports.ionOptions_IonNetworkFromJSON = ionOptions_IonNetworkFromJSON;
function ionOptions_IonNetworkToJSON(object) {
    switch (object) {
        case IonOptions_IonNetwork.TestNet:
            return "TestNet";
        case IonOptions_IonNetwork.MainNet:
            return "MainNet";
        case IonOptions_IonNetwork.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.ionOptions_IonNetworkToJSON = ionOptions_IonNetworkToJSON;
function createBaseInviteRequest() {
    return { participant: 0, description: "", details: undefined };
}
exports.InviteRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participant !== 0) {
            writer.uint32(8).int32(message.participant);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.details !== undefined) {
            account_1.AccountDetails.encode(message.details, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInviteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participant = reader.int32();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.details = account_1.AccountDetails.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            participant: isSet(object.participant)
                ? participantTypeFromJSON(object.participant)
                : 0,
            description: isSet(object.description) ? String(object.description) : "",
            details: isSet(object.details)
                ? account_1.AccountDetails.fromJSON(object.details)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.participant !== undefined &&
            (obj.participant = participantTypeToJSON(message.participant));
        message.description !== undefined &&
            (obj.description = message.description);
        message.details !== undefined &&
            (obj.details = message.details
                ? account_1.AccountDetails.toJSON(message.details)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInviteRequest();
        message.participant = (_a = object.participant) !== null && _a !== void 0 ? _a : 0;
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.details =
            object.details !== undefined && object.details !== null
                ? account_1.AccountDetails.fromPartial(object.details)
                : undefined;
        return message;
    },
};
function createBaseInviteRequest_DidCommInvitation() {
    return {};
}
exports.InviteRequest_DidCommInvitation = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInviteRequest_DidCommInvitation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseInviteRequest_DidCommInvitation();
        return message;
    },
};
function createBaseInviteResponse() {
    return { invitationId: "", invitationCode: "" };
}
exports.InviteResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.invitationId !== "") {
            writer.uint32(82).string(message.invitationId);
        }
        if (message.invitationCode !== "") {
            writer.uint32(90).string(message.invitationCode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInviteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 10:
                    message.invitationId = reader.string();
                    break;
                case 11:
                    message.invitationCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            invitationId: isSet(object.invitationId)
                ? String(object.invitationId)
                : "",
            invitationCode: isSet(object.invitationCode)
                ? String(object.invitationCode)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.invitationId !== undefined &&
            (obj.invitationId = message.invitationId);
        message.invitationCode !== undefined &&
            (obj.invitationCode = message.invitationCode);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInviteResponse();
        message.invitationId = (_a = object.invitationId) !== null && _a !== void 0 ? _a : "";
        message.invitationCode = (_b = object.invitationCode) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseInvitationStatusRequest() {
    return { invitationId: "" };
}
exports.InvitationStatusRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.invitationId !== "") {
            writer.uint32(10).string(message.invitationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationStatusRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.invitationId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            invitationId: isSet(object.invitationId)
                ? String(object.invitationId)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.invitationId !== undefined &&
            (obj.invitationId = message.invitationId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInvitationStatusRequest();
        message.invitationId = (_a = object.invitationId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseInvitationStatusResponse() {
    return { status: 0, statusDetails: "" };
}
exports.InvitationStatusResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== 0) {
            writer.uint32(8).int32(message.status);
        }
        if (message.statusDetails !== "") {
            writer.uint32(18).string(message.statusDetails);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.statusDetails = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet(object.status)
                ? invitationStatusResponse_StatusFromJSON(object.status)
                : 0,
            statusDetails: isSet(object.statusDetails)
                ? String(object.statusDetails)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.status !== undefined &&
            (obj.status = invitationStatusResponse_StatusToJSON(message.status));
        message.statusDetails !== undefined &&
            (obj.statusDetails = message.statusDetails);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInvitationStatusResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;
        message.statusDetails = (_b = object.statusDetails) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseEcosystem() {
    return {
        id: "",
        name: "",
        description: "",
        uri: "",
        webhooks: [],
        display: undefined,
        domain: "",
    };
}
exports.Ecosystem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.uri !== "") {
            writer.uint32(34).string(message.uri);
        }
        for (const v of message.webhooks) {
            exports.WebhookConfig.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.display !== undefined) {
            exports.EcosystemDisplay.encode(message.display, writer.uint32(50).fork()).ldelim();
        }
        if (message.domain !== "") {
            writer.uint32(58).string(message.domain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEcosystem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.uri = reader.string();
                    break;
                case 5:
                    message.webhooks.push(exports.WebhookConfig.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.display = exports.EcosystemDisplay.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            uri: isSet(object.uri) ? String(object.uri) : "",
            webhooks: Array.isArray(object === null || object === void 0 ? void 0 : object.webhooks)
                ? object.webhooks.map((e) => exports.WebhookConfig.fromJSON(e))
                : [],
            display: isSet(object.display)
                ? exports.EcosystemDisplay.fromJSON(object.display)
                : undefined,
            domain: isSet(object.domain) ? String(object.domain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined &&
            (obj.description = message.description);
        message.uri !== undefined && (obj.uri = message.uri);
        if (message.webhooks) {
            obj.webhooks = message.webhooks.map((e) => e ? exports.WebhookConfig.toJSON(e) : undefined);
        }
        else {
            obj.webhooks = [];
        }
        message.display !== undefined &&
            (obj.display = message.display
                ? exports.EcosystemDisplay.toJSON(message.display)
                : undefined);
        message.domain !== undefined && (obj.domain = message.domain);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseEcosystem();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.description = (_c = object.description) !== null && _c !== void 0 ? _c : "";
        message.uri = (_d = object.uri) !== null && _d !== void 0 ? _d : "";
        message.webhooks =
            ((_e = object.webhooks) === null || _e === void 0 ? void 0 : _e.map((e) => exports.WebhookConfig.fromPartial(e))) || [];
        message.display =
            object.display !== undefined && object.display !== null
                ? exports.EcosystemDisplay.fromPartial(object.display)
                : undefined;
        message.domain = (_f = object.domain) !== null && _f !== void 0 ? _f : "";
        return message;
    },
};
function createBaseWebhookConfig() {
    return { id: "", destinationUrl: "", events: [], status: "" };
}
exports.WebhookConfig = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.destinationUrl !== "") {
            writer.uint32(18).string(message.destinationUrl);
        }
        for (const v of message.events) {
            writer.uint32(34).string(v);
        }
        if (message.status !== "") {
            writer.uint32(42).string(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebhookConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.destinationUrl = reader.string();
                    break;
                case 4:
                    message.events.push(reader.string());
                    break;
                case 5:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            destinationUrl: isSet(object.destinationUrl)
                ? String(object.destinationUrl)
                : "",
            events: Array.isArray(object === null || object === void 0 ? void 0 : object.events)
                ? object.events.map((e) => String(e))
                : [],
            status: isSet(object.status) ? String(object.status) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.destinationUrl !== undefined &&
            (obj.destinationUrl = message.destinationUrl);
        if (message.events) {
            obj.events = message.events.map((e) => e);
        }
        else {
            obj.events = [];
        }
        message.status !== undefined && (obj.status = message.status);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseWebhookConfig();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.destinationUrl = (_b = object.destinationUrl) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.status = (_d = object.status) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseGrant() {
    return { resourceId: "", actions: [], childGrants: [] };
}
exports.Grant = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.resourceId !== "") {
            writer.uint32(10).string(message.resourceId);
        }
        for (const v of message.actions) {
            writer.uint32(18).string(v);
        }
        for (const v of message.childGrants) {
            exports.Grant.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resourceId = reader.string();
                    break;
                case 2:
                    message.actions.push(reader.string());
                    break;
                case 3:
                    message.childGrants.push(exports.Grant.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            resourceId: isSet(object.resourceId) ? String(object.resourceId) : "",
            actions: Array.isArray(object === null || object === void 0 ? void 0 : object.actions)
                ? object.actions.map((e) => String(e))
                : [],
            childGrants: Array.isArray(object === null || object === void 0 ? void 0 : object.childGrants)
                ? object.childGrants.map((e) => exports.Grant.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.resourceId !== undefined && (obj.resourceId = message.resourceId);
        if (message.actions) {
            obj.actions = message.actions.map((e) => e);
        }
        else {
            obj.actions = [];
        }
        if (message.childGrants) {
            obj.childGrants = message.childGrants.map((e) => e ? exports.Grant.toJSON(e) : undefined);
        }
        else {
            obj.childGrants = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseGrant();
        message.resourceId = (_a = object.resourceId) !== null && _a !== void 0 ? _a : "";
        message.actions = ((_b = object.actions) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.childGrants =
            ((_c = object.childGrants) === null || _c === void 0 ? void 0 : _c.map((e) => exports.Grant.fromPartial(e))) || [];
        return message;
    },
};
function createBaseCreateEcosystemRequest() {
    return { name: "", description: "", uri: "", details: undefined, domain: "" };
}
exports.CreateEcosystemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.uri !== "") {
            writer.uint32(26).string(message.uri);
        }
        if (message.details !== undefined) {
            account_1.AccountDetails.encode(message.details, writer.uint32(34).fork()).ldelim();
        }
        if (message.domain !== "") {
            writer.uint32(42).string(message.domain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEcosystemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.uri = reader.string();
                    break;
                case 4:
                    message.details = account_1.AccountDetails.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            uri: isSet(object.uri) ? String(object.uri) : "",
            details: isSet(object.details)
                ? account_1.AccountDetails.fromJSON(object.details)
                : undefined,
            domain: isSet(object.domain) ? String(object.domain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined &&
            (obj.description = message.description);
        message.uri !== undefined && (obj.uri = message.uri);
        message.details !== undefined &&
            (obj.details = message.details
                ? account_1.AccountDetails.toJSON(message.details)
                : undefined);
        message.domain !== undefined && (obj.domain = message.domain);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseCreateEcosystemRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.uri = (_c = object.uri) !== null && _c !== void 0 ? _c : "";
        message.details =
            object.details !== undefined && object.details !== null
                ? account_1.AccountDetails.fromPartial(object.details)
                : undefined;
        message.domain = (_d = object.domain) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseCreateEcosystemResponse() {
    return { ecosystem: undefined, profile: undefined, confirmationMethod: 0 };
}
exports.CreateEcosystemResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystem !== undefined) {
            exports.Ecosystem.encode(message.ecosystem, writer.uint32(10).fork()).ldelim();
        }
        if (message.profile !== undefined) {
            account_1.AccountProfile.encode(message.profile, writer.uint32(18).fork()).ldelim();
        }
        if (message.confirmationMethod !== 0) {
            writer.uint32(24).int32(message.confirmationMethod);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEcosystemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystem = exports.Ecosystem.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.profile = account_1.AccountProfile.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.confirmationMethod = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystem: isSet(object.ecosystem)
                ? exports.Ecosystem.fromJSON(object.ecosystem)
                : undefined,
            profile: isSet(object.profile)
                ? account_1.AccountProfile.fromJSON(object.profile)
                : undefined,
            confirmationMethod: isSet(object.confirmationMethod)
                ? (0, account_1.confirmationMethodFromJSON)(object.confirmationMethod)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystem !== undefined &&
            (obj.ecosystem = message.ecosystem
                ? exports.Ecosystem.toJSON(message.ecosystem)
                : undefined);
        message.profile !== undefined &&
            (obj.profile = message.profile
                ? account_1.AccountProfile.toJSON(message.profile)
                : undefined);
        message.confirmationMethod !== undefined &&
            (obj.confirmationMethod = (0, account_1.confirmationMethodToJSON)(message.confirmationMethod));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCreateEcosystemResponse();
        message.ecosystem =
            object.ecosystem !== undefined && object.ecosystem !== null
                ? exports.Ecosystem.fromPartial(object.ecosystem)
                : undefined;
        message.profile =
            object.profile !== undefined && object.profile !== null
                ? account_1.AccountProfile.fromPartial(object.profile)
                : undefined;
        message.confirmationMethod = (_a = object.confirmationMethod) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseUpdateEcosystemRequest() {
    return { description: "", uri: "", domain: "", name: "", display: undefined };
}
exports.UpdateEcosystemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.uri !== "") {
            writer.uint32(18).string(message.uri);
        }
        if (message.domain !== "") {
            writer.uint32(26).string(message.domain);
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        if (message.display !== undefined) {
            exports.EcosystemDisplay.encode(message.display, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEcosystemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.uri = reader.string();
                    break;
                case 3:
                    message.domain = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.display = exports.EcosystemDisplay.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? String(object.description) : "",
            uri: isSet(object.uri) ? String(object.uri) : "",
            domain: isSet(object.domain) ? String(object.domain) : "",
            name: isSet(object.name) ? String(object.name) : "",
            display: isSet(object.display)
                ? exports.EcosystemDisplay.fromJSON(object.display)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined &&
            (obj.description = message.description);
        message.uri !== undefined && (obj.uri = message.uri);
        message.domain !== undefined && (obj.domain = message.domain);
        message.name !== undefined && (obj.name = message.name);
        message.display !== undefined &&
            (obj.display = message.display
                ? exports.EcosystemDisplay.toJSON(message.display)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUpdateEcosystemRequest();
        message.description = (_a = object.description) !== null && _a !== void 0 ? _a : "";
        message.uri = (_b = object.uri) !== null && _b !== void 0 ? _b : "";
        message.domain = (_c = object.domain) !== null && _c !== void 0 ? _c : "";
        message.name = (_d = object.name) !== null && _d !== void 0 ? _d : "";
        message.display =
            object.display !== undefined && object.display !== null
                ? exports.EcosystemDisplay.fromPartial(object.display)
                : undefined;
        return message;
    },
};
function createBaseEcosystemDisplay() {
    return { dark: undefined, light: undefined };
}
exports.EcosystemDisplay = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dark !== undefined) {
            exports.EcosystemDisplayDetails.encode(message.dark, writer.uint32(10).fork()).ldelim();
        }
        if (message.light !== undefined) {
            exports.EcosystemDisplayDetails.encode(message.light, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEcosystemDisplay();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dark = exports.EcosystemDisplayDetails.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.light = exports.EcosystemDisplayDetails.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            dark: isSet(object.dark)
                ? exports.EcosystemDisplayDetails.fromJSON(object.dark)
                : undefined,
            light: isSet(object.light)
                ? exports.EcosystemDisplayDetails.fromJSON(object.light)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.dark !== undefined &&
            (obj.dark = message.dark
                ? exports.EcosystemDisplayDetails.toJSON(message.dark)
                : undefined);
        message.light !== undefined &&
            (obj.light = message.light
                ? exports.EcosystemDisplayDetails.toJSON(message.light)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEcosystemDisplay();
        message.dark =
            object.dark !== undefined && object.dark !== null
                ? exports.EcosystemDisplayDetails.fromPartial(object.dark)
                : undefined;
        message.light =
            object.light !== undefined && object.light !== null
                ? exports.EcosystemDisplayDetails.fromPartial(object.light)
                : undefined;
        return message;
    },
};
function createBaseEcosystemDisplayDetails() {
    return { logoUrl: "", color: "" };
}
exports.EcosystemDisplayDetails = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.logoUrl !== "") {
            writer.uint32(26).string(message.logoUrl);
        }
        if (message.color !== "") {
            writer.uint32(34).string(message.color);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEcosystemDisplayDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.logoUrl = reader.string();
                    break;
                case 4:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            logoUrl: isSet(object.logoUrl) ? String(object.logoUrl) : "",
            color: isSet(object.color) ? String(object.color) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.logoUrl !== undefined && (obj.logoUrl = message.logoUrl);
        message.color !== undefined && (obj.color = message.color);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEcosystemDisplayDetails();
        message.logoUrl = (_a = object.logoUrl) !== null && _a !== void 0 ? _a : "";
        message.color = (_b = object.color) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseUpdateEcosystemResponse() {
    return { Ecosystem: undefined };
}
exports.UpdateEcosystemResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.Ecosystem !== undefined) {
            exports.Ecosystem.encode(message.Ecosystem, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEcosystemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Ecosystem = exports.Ecosystem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            Ecosystem: isSet(object.Ecosystem)
                ? exports.Ecosystem.fromJSON(object.Ecosystem)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.Ecosystem !== undefined &&
            (obj.Ecosystem = message.Ecosystem
                ? exports.Ecosystem.toJSON(message.Ecosystem)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUpdateEcosystemResponse();
        message.Ecosystem =
            object.Ecosystem !== undefined && object.Ecosystem !== null
                ? exports.Ecosystem.fromPartial(object.Ecosystem)
                : undefined;
        return message;
    },
};
function createBaseAddWebhookRequest() {
    return { destinationUrl: "", secret: "", events: [] };
}
exports.AddWebhookRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.destinationUrl !== "") {
            writer.uint32(10).string(message.destinationUrl);
        }
        if (message.secret !== "") {
            writer.uint32(18).string(message.secret);
        }
        for (const v of message.events) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddWebhookRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.destinationUrl = reader.string();
                    break;
                case 2:
                    message.secret = reader.string();
                    break;
                case 3:
                    message.events.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            destinationUrl: isSet(object.destinationUrl)
                ? String(object.destinationUrl)
                : "",
            secret: isSet(object.secret) ? String(object.secret) : "",
            events: Array.isArray(object === null || object === void 0 ? void 0 : object.events)
                ? object.events.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.destinationUrl !== undefined &&
            (obj.destinationUrl = message.destinationUrl);
        message.secret !== undefined && (obj.secret = message.secret);
        if (message.events) {
            obj.events = message.events.map((e) => e);
        }
        else {
            obj.events = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAddWebhookRequest();
        message.destinationUrl = (_a = object.destinationUrl) !== null && _a !== void 0 ? _a : "";
        message.secret = (_b = object.secret) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
function createBaseAddWebhookResponse() {
    return { ecosystem: undefined };
}
exports.AddWebhookResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystem !== undefined) {
            exports.Ecosystem.encode(message.ecosystem, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddWebhookResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystem = exports.Ecosystem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystem: isSet(object.ecosystem)
                ? exports.Ecosystem.fromJSON(object.ecosystem)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystem !== undefined &&
            (obj.ecosystem = message.ecosystem
                ? exports.Ecosystem.toJSON(message.ecosystem)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAddWebhookResponse();
        message.ecosystem =
            object.ecosystem !== undefined && object.ecosystem !== null
                ? exports.Ecosystem.fromPartial(object.ecosystem)
                : undefined;
        return message;
    },
};
function createBaseDeleteWebhookRequest() {
    return { webhookId: "" };
}
exports.DeleteWebhookRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.webhookId !== "") {
            writer.uint32(10).string(message.webhookId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteWebhookRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.webhookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            webhookId: isSet(object.webhookId) ? String(object.webhookId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.webhookId !== undefined && (obj.webhookId = message.webhookId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseDeleteWebhookRequest();
        message.webhookId = (_a = object.webhookId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteWebhookResponse() {
    return { ecosystem: undefined };
}
exports.DeleteWebhookResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystem !== undefined) {
            exports.Ecosystem.encode(message.ecosystem, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteWebhookResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystem = exports.Ecosystem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystem: isSet(object.ecosystem)
                ? exports.Ecosystem.fromJSON(object.ecosystem)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystem !== undefined &&
            (obj.ecosystem = message.ecosystem
                ? exports.Ecosystem.toJSON(message.ecosystem)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseDeleteWebhookResponse();
        message.ecosystem =
            object.ecosystem !== undefined && object.ecosystem !== null
                ? exports.Ecosystem.fromPartial(object.ecosystem)
                : undefined;
        return message;
    },
};
function createBaseEcosystemInfoRequest() {
    return {};
}
exports.EcosystemInfoRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEcosystemInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseEcosystemInfoRequest();
        return message;
    },
};
function createBaseEcosystemInfoResponse() {
    return { ecosystem: undefined };
}
exports.EcosystemInfoResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystem !== undefined) {
            exports.Ecosystem.encode(message.ecosystem, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEcosystemInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystem = exports.Ecosystem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystem: isSet(object.ecosystem)
                ? exports.Ecosystem.fromJSON(object.ecosystem)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystem !== undefined &&
            (obj.ecosystem = message.ecosystem
                ? exports.Ecosystem.toJSON(message.ecosystem)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEcosystemInfoResponse();
        message.ecosystem =
            object.ecosystem !== undefined && object.ecosystem !== null
                ? exports.Ecosystem.fromPartial(object.ecosystem)
                : undefined;
        return message;
    },
};
function createBaseGetPublicEcosystemInfoRequest() {
    return { ecosystemId: "" };
}
exports.GetPublicEcosystemInfoRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystemId !== "") {
            writer.uint32(10).string(message.ecosystemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPublicEcosystemInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystemId: isSet(object.ecosystemId) ? String(object.ecosystemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystemId !== undefined &&
            (obj.ecosystemId = message.ecosystemId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetPublicEcosystemInfoRequest();
        message.ecosystemId = (_a = object.ecosystemId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetPublicEcosystemInfoResponse() {
    return { ecosystem: undefined };
}
exports.GetPublicEcosystemInfoResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ecosystem !== undefined) {
            exports.PublicEcosystemInformation.encode(message.ecosystem, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPublicEcosystemInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ecosystem = exports.PublicEcosystemInformation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            ecosystem: isSet(object.ecosystem)
                ? exports.PublicEcosystemInformation.fromJSON(object.ecosystem)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.ecosystem !== undefined &&
            (obj.ecosystem = message.ecosystem
                ? exports.PublicEcosystemInformation.toJSON(message.ecosystem)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetPublicEcosystemInfoResponse();
        message.ecosystem =
            object.ecosystem !== undefined && object.ecosystem !== null
                ? exports.PublicEcosystemInformation.fromPartial(object.ecosystem)
                : undefined;
        return message;
    },
};
function createBasePublicEcosystemInformation() {
    return {
        name: "",
        domain: "",
        domainVerified: false,
        styleDisplay: undefined,
    };
}
exports.PublicEcosystemInformation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.domain !== "") {
            writer.uint32(18).string(message.domain);
        }
        if (message.domainVerified === true) {
            writer.uint32(24).bool(message.domainVerified);
        }
        if (message.styleDisplay !== undefined) {
            exports.EcosystemDisplay.encode(message.styleDisplay, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicEcosystemInformation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.domain = reader.string();
                    break;
                case 3:
                    message.domainVerified = reader.bool();
                    break;
                case 4:
                    message.styleDisplay = exports.EcosystemDisplay.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            domain: isSet(object.domain) ? String(object.domain) : "",
            domainVerified: isSet(object.domainVerified)
                ? Boolean(object.domainVerified)
                : false,
            styleDisplay: isSet(object.styleDisplay)
                ? exports.EcosystemDisplay.fromJSON(object.styleDisplay)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.domain !== undefined && (obj.domain = message.domain);
        message.domainVerified !== undefined &&
            (obj.domainVerified = message.domainVerified);
        message.styleDisplay !== undefined &&
            (obj.styleDisplay = message.styleDisplay
                ? exports.EcosystemDisplay.toJSON(message.styleDisplay)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePublicEcosystemInformation();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.domain = (_b = object.domain) !== null && _b !== void 0 ? _b : "";
        message.domainVerified = (_c = object.domainVerified) !== null && _c !== void 0 ? _c : false;
        message.styleDisplay =
            object.styleDisplay !== undefined && object.styleDisplay !== null
                ? exports.EcosystemDisplay.fromPartial(object.styleDisplay)
                : undefined;
        return message;
    },
};
function createBaseGenerateTokenRequest() {
    return { description: "" };
}
exports.GenerateTokenRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? String(object.description) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.description !== undefined &&
            (obj.description = message.description);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGenerateTokenRequest();
        message.description = (_a = object.description) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGenerateTokenResponse() {
    return { profile: undefined };
}
exports.GenerateTokenResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.profile !== undefined) {
            account_1.AccountProfile.encode(message.profile, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profile = account_1.AccountProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            profile: isSet(object.profile)
                ? account_1.AccountProfile.fromJSON(object.profile)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.profile !== undefined &&
            (obj.profile = message.profile
                ? account_1.AccountProfile.toJSON(message.profile)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGenerateTokenResponse();
        message.profile =
            object.profile !== undefined && object.profile !== null
                ? account_1.AccountProfile.fromPartial(object.profile)
                : undefined;
        return message;
    },
};
function createBaseGetOberonKeyRequest() {
    return {};
}
exports.GetOberonKeyRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOberonKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseGetOberonKeyRequest();
        return message;
    },
};
function createBaseGetOberonKeyResponse() {
    return { key: "" };
}
exports.GetOberonKeyResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOberonKeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetOberonKeyResponse();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetEventTokenRequest() {
    return { pk: new Uint8Array() };
}
exports.GetEventTokenRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pk.length !== 0) {
            writer.uint32(10).bytes(message.pk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEventTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetEventTokenRequest();
        message.pk = (_a = object.pk) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseGetEventTokenResponse() {
    return { token: "" };
}
exports.GetEventTokenResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.token !== "") {
            writer.uint32(10).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEventTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetEventTokenResponse();
        message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseRetrieveDomainVerificationRecordRequest() {
    return {};
}
exports.RetrieveDomainVerificationRecordRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRetrieveDomainVerificationRecordRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRetrieveDomainVerificationRecordRequest();
        return message;
    },
};
function createBaseRetrieveDomainVerificationRecordResponse() {
    return { verificationTxt: "" };
}
exports.RetrieveDomainVerificationRecordResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.verificationTxt !== "") {
            writer.uint32(10).string(message.verificationTxt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRetrieveDomainVerificationRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.verificationTxt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            verificationTxt: isSet(object.verificationTxt)
                ? String(object.verificationTxt)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.verificationTxt !== undefined &&
            (obj.verificationTxt = message.verificationTxt);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRetrieveDomainVerificationRecordResponse();
        message.verificationTxt = (_a = object.verificationTxt) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseRefreshDomainVerificationStatusRequest() {
    return {};
}
exports.RefreshDomainVerificationStatusRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshDomainVerificationStatusRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRefreshDomainVerificationStatusRequest();
        return message;
    },
};
function createBaseRefreshDomainVerificationStatusResponse() {
    return { domain: "", domainVerified: false };
}
exports.RefreshDomainVerificationStatusResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.domain !== "") {
            writer.uint32(10).string(message.domain);
        }
        if (message.domainVerified === true) {
            writer.uint32(16).bool(message.domainVerified);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshDomainVerificationStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.domain = reader.string();
                    break;
                case 2:
                    message.domainVerified = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            domain: isSet(object.domain) ? String(object.domain) : "",
            domainVerified: isSet(object.domainVerified)
                ? Boolean(object.domainVerified)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.domain !== undefined && (obj.domain = message.domain);
        message.domainVerified !== undefined &&
            (obj.domainVerified = message.domainVerified);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRefreshDomainVerificationStatusResponse();
        message.domain = (_a = object.domain) !== null && _a !== void 0 ? _a : "";
        message.domainVerified = (_b = object.domainVerified) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseGrantAuthorizationRequest() {
    return { email: undefined, walletId: undefined, resource: "", action: "" };
}
exports.GrantAuthorizationRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.email !== undefined) {
            writer.uint32(10).string(message.email);
        }
        if (message.walletId !== undefined) {
            writer.uint32(18).string(message.walletId);
        }
        if (message.resource !== "") {
            writer.uint32(26).string(message.resource);
        }
        if (message.action !== "") {
            writer.uint32(34).string(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorizationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.walletId = reader.string();
                    break;
                case 3:
                    message.resource = reader.string();
                    break;
                case 4:
                    message.action = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            email: isSet(object.email) ? String(object.email) : undefined,
            walletId: isSet(object.walletId) ? String(object.walletId) : undefined,
            resource: isSet(object.resource) ? String(object.resource) : "",
            action: isSet(object.action) ? String(object.action) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.email !== undefined && (obj.email = message.email);
        message.walletId !== undefined && (obj.walletId = message.walletId);
        message.resource !== undefined && (obj.resource = message.resource);
        message.action !== undefined && (obj.action = message.action);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseGrantAuthorizationRequest();
        message.email = (_a = object.email) !== null && _a !== void 0 ? _a : undefined;
        message.walletId = (_b = object.walletId) !== null && _b !== void 0 ? _b : undefined;
        message.resource = (_c = object.resource) !== null && _c !== void 0 ? _c : "";
        message.action = (_d = object.action) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseGrantAuthorizationResponse() {
    return {};
}
exports.GrantAuthorizationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorizationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseGrantAuthorizationResponse();
        return message;
    },
};
function createBaseRevokeAuthorizationRequest() {
    return { email: undefined, walletId: undefined, resource: "", action: "" };
}
exports.RevokeAuthorizationRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.email !== undefined) {
            writer.uint32(10).string(message.email);
        }
        if (message.walletId !== undefined) {
            writer.uint32(18).string(message.walletId);
        }
        if (message.resource !== "") {
            writer.uint32(26).string(message.resource);
        }
        if (message.action !== "") {
            writer.uint32(34).string(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAuthorizationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.walletId = reader.string();
                    break;
                case 3:
                    message.resource = reader.string();
                    break;
                case 4:
                    message.action = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            email: isSet(object.email) ? String(object.email) : undefined,
            walletId: isSet(object.walletId) ? String(object.walletId) : undefined,
            resource: isSet(object.resource) ? String(object.resource) : "",
            action: isSet(object.action) ? String(object.action) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.email !== undefined && (obj.email = message.email);
        message.walletId !== undefined && (obj.walletId = message.walletId);
        message.resource !== undefined && (obj.resource = message.resource);
        message.action !== undefined && (obj.action = message.action);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseRevokeAuthorizationRequest();
        message.email = (_a = object.email) !== null && _a !== void 0 ? _a : undefined;
        message.walletId = (_b = object.walletId) !== null && _b !== void 0 ? _b : undefined;
        message.resource = (_c = object.resource) !== null && _c !== void 0 ? _c : "";
        message.action = (_d = object.action) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseRevokeAuthorizationResponse() {
    return {};
}
exports.RevokeAuthorizationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAuthorizationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRevokeAuthorizationResponse();
        return message;
    },
};
function createBaseGetAuthorizationsRequest() {
    return {};
}
exports.GetAuthorizationsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAuthorizationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseGetAuthorizationsRequest();
        return message;
    },
};
function createBaseGetAuthorizationsResponse() {
    return { grants: [] };
}
exports.GetAuthorizationsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.grants) {
            exports.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAuthorizationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.grants.push(exports.Grant.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants)
                ? object.grants.map((e) => exports.Grant.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.grants) {
            obj.grants = message.grants.map((e) => (e ? exports.Grant.toJSON(e) : undefined));
        }
        else {
            obj.grants = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetAuthorizationsResponse();
        message.grants = ((_a = object.grants) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Grant.fromPartial(e))) || [];
        return message;
    },
};
function createBaseSearchWalletConfigurationsRequest() {
    return { queryFilter: "", continuationToken: "" };
}
exports.SearchWalletConfigurationsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.queryFilter !== "") {
            writer.uint32(10).string(message.queryFilter);
        }
        if (message.continuationToken !== "") {
            writer.uint32(18).string(message.continuationToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchWalletConfigurationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.queryFilter = reader.string();
                    break;
                case 2:
                    message.continuationToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            queryFilter: isSet(object.queryFilter) ? String(object.queryFilter) : "",
            continuationToken: isSet(object.continuationToken)
                ? String(object.continuationToken)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.queryFilter !== undefined &&
            (obj.queryFilter = message.queryFilter);
        message.continuationToken !== undefined &&
            (obj.continuationToken = message.continuationToken);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSearchWalletConfigurationsRequest();
        message.queryFilter = (_a = object.queryFilter) !== null && _a !== void 0 ? _a : "";
        message.continuationToken = (_b = object.continuationToken) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseSearchWalletConfigurationResponse() {
    return { results: [], hasMore: false, continuationToken: "" };
}
exports.SearchWalletConfigurationResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            exports.WalletConfiguration.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.hasMore === true) {
            writer.uint32(16).bool(message.hasMore);
        }
        if (message.continuationToken !== "") {
            writer.uint32(34).string(message.continuationToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchWalletConfigurationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.results.push(exports.WalletConfiguration.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hasMore = reader.bool();
                    break;
                case 4:
                    message.continuationToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: Array.isArray(object === null || object === void 0 ? void 0 : object.results)
                ? object.results.map((e) => exports.WalletConfiguration.fromJSON(e))
                : [],
            hasMore: isSet(object.hasMore) ? Boolean(object.hasMore) : false,
            continuationToken: isSet(object.continuationToken)
                ? String(object.continuationToken)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results) {
            obj.results = message.results.map((e) => e ? exports.WalletConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.results = [];
        }
        message.hasMore !== undefined && (obj.hasMore = message.hasMore);
        message.continuationToken !== undefined &&
            (obj.continuationToken = message.continuationToken);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSearchWalletConfigurationResponse();
        message.results =
            ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => exports.WalletConfiguration.fromPartial(e))) || [];
        message.hasMore = (_b = object.hasMore) !== null && _b !== void 0 ? _b : false;
        message.continuationToken = (_c = object.continuationToken) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseWalletConfiguration() {
    return { name: "", email: "", sms: "", walletId: "", publicDid: "" };
}
exports.WalletConfiguration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.email !== "") {
            writer.uint32(18).string(message.email);
        }
        if (message.sms !== "") {
            writer.uint32(26).string(message.sms);
        }
        if (message.walletId !== "") {
            writer.uint32(34).string(message.walletId);
        }
        if (message.publicDid !== "") {
            writer.uint32(42).string(message.publicDid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWalletConfiguration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.sms = reader.string();
                    break;
                case 4:
                    message.walletId = reader.string();
                    break;
                case 5:
                    message.publicDid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            email: isSet(object.email) ? String(object.email) : "",
            sms: isSet(object.sms) ? String(object.sms) : "",
            walletId: isSet(object.walletId) ? String(object.walletId) : "",
            publicDid: isSet(object.publicDid) ? String(object.publicDid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.email !== undefined && (obj.email = message.email);
        message.sms !== undefined && (obj.sms = message.sms);
        message.walletId !== undefined && (obj.walletId = message.walletId);
        message.publicDid !== undefined && (obj.publicDid = message.publicDid);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseWalletConfiguration();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.email = (_b = object.email) !== null && _b !== void 0 ? _b : "";
        message.sms = (_c = object.sms) !== null && _c !== void 0 ? _c : "";
        message.walletId = (_d = object.walletId) !== null && _d !== void 0 ? _d : "";
        message.publicDid = (_e = object.publicDid) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseIonOptions() {
    return { network: 0 };
}
exports.IonOptions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.network !== 0) {
            writer.uint32(8).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIonOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.network = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            network: isSet(object.network)
                ? ionOptions_IonNetworkFromJSON(object.network)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.network !== undefined &&
            (obj.network = ionOptions_IonNetworkToJSON(message.network));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseIonOptions();
        message.network = (_a = object.network) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseUpgradeDidRequest() {
    return {
        email: undefined,
        walletId: undefined,
        method: 0,
        ionOptions: undefined,
    };
}
exports.UpgradeDidRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.email !== undefined) {
            writer.uint32(10).string(message.email);
        }
        if (message.walletId !== undefined) {
            writer.uint32(18).string(message.walletId);
        }
        if (message.method !== 0) {
            writer.uint32(24).int32(message.method);
        }
        if (message.ionOptions !== undefined) {
            exports.IonOptions.encode(message.ionOptions, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeDidRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.walletId = reader.string();
                    break;
                case 3:
                    message.method = reader.int32();
                    break;
                case 4:
                    message.ionOptions = exports.IonOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            email: isSet(object.email) ? String(object.email) : undefined,
            walletId: isSet(object.walletId) ? String(object.walletId) : undefined,
            method: isSet(object.method)
                ? (0, common_1.supportedDidMethodFromJSON)(object.method)
                : 0,
            ionOptions: isSet(object.ionOptions)
                ? exports.IonOptions.fromJSON(object.ionOptions)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.email !== undefined && (obj.email = message.email);
        message.walletId !== undefined && (obj.walletId = message.walletId);
        message.method !== undefined &&
            (obj.method = (0, common_1.supportedDidMethodToJSON)(message.method));
        message.ionOptions !== undefined &&
            (obj.ionOptions = message.ionOptions
                ? exports.IonOptions.toJSON(message.ionOptions)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUpgradeDidRequest();
        message.email = (_a = object.email) !== null && _a !== void 0 ? _a : undefined;
        message.walletId = (_b = object.walletId) !== null && _b !== void 0 ? _b : undefined;
        message.method = (_c = object.method) !== null && _c !== void 0 ? _c : 0;
        message.ionOptions =
            object.ionOptions !== undefined && object.ionOptions !== null
                ? exports.IonOptions.fromPartial(object.ionOptions)
                : undefined;
        return message;
    },
};
function createBaseUpgradeDidResponse() {
    return { did: "" };
}
exports.UpgradeDidResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.did !== "") {
            writer.uint32(10).string(message.did);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeDidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.did = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            did: isSet(object.did) ? String(object.did) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.did !== undefined && (obj.did = message.did);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUpgradeDidResponse();
        message.did = (_a = object.did) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
exports.ProviderDefinition = {
    name: "Provider",
    fullName: "services.provider.v1.Provider",
    methods: {
        /** Create new ecosystem and assign the authenticated user as owner */
        createEcosystem: {
            name: "CreateEcosystem",
            requestType: exports.CreateEcosystemRequest,
            requestStream: false,
            responseType: exports.CreateEcosystemResponse,
            responseStream: false,
            options: {},
        },
        /** Update an existing ecosystem */
        updateEcosystem: {
            name: "UpdateEcosystem",
            requestType: exports.UpdateEcosystemRequest,
            requestStream: false,
            responseType: exports.UpdateEcosystemResponse,
            responseStream: false,
            options: {},
        },
        /** Grant user authorization to ecosystem resources */
        grantAuthorization: {
            name: "GrantAuthorization",
            requestType: exports.GrantAuthorizationRequest,
            requestStream: false,
            responseType: exports.GrantAuthorizationResponse,
            responseStream: false,
            options: {},
        },
        /** Revoke user authorization to ecosystem resources */
        revokeAuthorization: {
            name: "RevokeAuthorization",
            requestType: exports.RevokeAuthorizationRequest,
            requestStream: false,
            responseType: exports.RevokeAuthorizationResponse,
            responseStream: false,
            options: {},
        },
        /** Retrieve the list of permissions for this particular account/ecosystem */
        getAuthorizations: {
            name: "GetAuthorizations",
            requestType: exports.GetAuthorizationsRequest,
            requestStream: false,
            responseType: exports.GetAuthorizationsResponse,
            responseStream: false,
            options: {},
        },
        /** Add a webhook endpoint to the ecosystem */
        addWebhook: {
            name: "AddWebhook",
            requestType: exports.AddWebhookRequest,
            requestStream: false,
            responseType: exports.AddWebhookResponse,
            responseStream: false,
            options: {},
        },
        /** Delete a webhook endpoint from the ecosystem */
        deleteWebhook: {
            name: "DeleteWebhook",
            requestType: exports.DeleteWebhookRequest,
            requestStream: false,
            responseType: exports.DeleteWebhookResponse,
            responseStream: false,
            options: {},
        },
        /** Get ecosystem information */
        ecosystemInfo: {
            name: "EcosystemInfo",
            requestType: exports.EcosystemInfoRequest,
            requestStream: false,
            responseType: exports.EcosystemInfoResponse,
            responseStream: false,
            options: {},
        },
        /** Get public ecosystem information about *any* ecosystem */
        getPublicEcosystemInfo: {
            name: "GetPublicEcosystemInfo",
            requestType: exports.GetPublicEcosystemInfoRequest,
            requestStream: false,
            responseType: exports.GetPublicEcosystemInfoResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Generates an unprotected authentication token that can be used to
         * configure server side applications
         */
        generateToken: {
            name: "GenerateToken",
            requestType: exports.GenerateTokenRequest,
            requestStream: false,
            responseType: exports.GenerateTokenResponse,
            responseStream: false,
            options: {},
        },
        /** Invite a user to the ecosystem */
        invite: {
            name: "Invite",
            requestType: exports.InviteRequest,
            requestStream: false,
            responseType: exports.InviteResponse,
            responseStream: false,
            options: {},
        },
        /** Check the status of an invitation */
        invitationStatus: {
            name: "InvitationStatus",
            requestType: exports.InvitationStatusRequest,
            requestStream: false,
            responseType: exports.InvitationStatusResponse,
            responseStream: false,
            options: {},
        },
        /** Returns the public key being used to create/verify oberon tokens */
        getOberonKey: {
            name: "GetOberonKey",
            requestType: exports.GetOberonKeyRequest,
            requestStream: false,
            responseType: exports.GetOberonKeyResponse,
            responseStream: false,
            options: {},
        },
        /** Generate a signed token (JWT) that can be used to connect to the message bus */
        getEventToken: {
            name: "GetEventToken",
            requestType: exports.GetEventTokenRequest,
            requestStream: false,
            responseType: exports.GetEventTokenResponse,
            responseStream: false,
            options: {},
        },
        /** Upgrade a wallet's DID from `did:key` to another method */
        upgradeDID: {
            name: "UpgradeDID",
            requestType: exports.UpgradeDidRequest,
            requestStream: false,
            responseType: exports.UpgradeDidResponse,
            responseStream: false,
            options: {},
        },
        /** Retrieve a random hash TXT that can be used to verify domain ownership */
        retrieveDomainVerificationRecord: {
            name: "RetrieveDomainVerificationRecord",
            requestType: exports.RetrieveDomainVerificationRecordRequest,
            requestStream: false,
            responseType: exports.RetrieveDomainVerificationRecordResponse,
            responseStream: false,
            options: {},
        },
        /** Call to verify domain */
        refreshDomainVerificationStatus: {
            name: "RefreshDomainVerificationStatus",
            requestType: exports.RefreshDomainVerificationStatusRequest,
            requestStream: false,
            responseType: exports.RefreshDomainVerificationStatusResponse,
            responseStream: false,
            options: {},
        },
        /** Search for issuers/providers/verifiers in the current ecosystem */
        searchWalletConfigurations: {
            name: "SearchWalletConfigurations",
            requestType: exports.SearchWalletConfigurationsRequest,
            requestStream: false,
            responseType: exports.SearchWalletConfigurationResponse,
            responseStream: false,
            options: {},
        },
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=provider.js.map