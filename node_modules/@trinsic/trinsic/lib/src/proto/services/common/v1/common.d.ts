import _m0 from "protobufjs/minimal";
export declare enum ResponseStatus {
    SUCCESS = 0,
    WALLET_ACCESS_DENIED = 10,
    WALLET_EXISTS = 11,
    ITEM_NOT_FOUND = 20,
    SERIALIZATION_ERROR = 200,
    UNKNOWN_ERROR = 100,
    UNRECOGNIZED = -1
}
export declare function responseStatusFromJSON(object: any): ResponseStatus;
export declare function responseStatusToJSON(object: ResponseStatus): string;
/** Enum of all supported DID Methods */
export declare enum SupportedDidMethod {
    /** KEY - The did:key method -- all wallets use this by default */
    KEY = 0,
    /** ION - The did:ion method */
    ION = 1,
    UNRECOGNIZED = -1
}
export declare function supportedDidMethodFromJSON(object: any): SupportedDidMethod;
export declare function supportedDidMethodToJSON(object: SupportedDidMethod): string;
/** Nonce used to generate an oberon proof */
export interface Nonce {
    /** UTC unix millisecond timestamp the request was made */
    timestamp: number;
    /** blake3256 hash of the request body */
    requestHash: Uint8Array;
}
export declare const Nonce: {
    encode(message: Nonce, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Nonce;
    fromJSON(object: any): Nonce;
    toJSON(message: Nonce): unknown;
    fromPartial(object: DeepPartial<Nonce>): Nonce;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
