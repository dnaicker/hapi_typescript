"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountDefinition = exports.AuthorizeWebhookResponse = exports.AuthorizeWebhookRequest = exports.LoginConfirmResponse = exports.LoginConfirmRequest = exports.LoginResponse = exports.LoginRequest = exports.AccountEcosystem = exports.RevokeDeviceResponse = exports.RevokeDeviceRequest = exports.ListDevicesResponse = exports.ListDevicesRequest = exports.AccountInfoResponse = exports.AccountInfoRequest = exports.TokenProtection = exports.AccountProfile = exports.SignInResponse = exports.AccountDetails = exports.SignInRequest = exports.confirmationMethodToJSON = exports.confirmationMethodFromJSON = exports.ConfirmationMethod = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
/** Confirmation method type for two-factor workflows */
var ConfirmationMethod;
(function (ConfirmationMethod) {
    /** None - No confirmation required */
    ConfirmationMethod[ConfirmationMethod["None"] = 0] = "None";
    /** Email - Email confirmation required */
    ConfirmationMethod[ConfirmationMethod["Email"] = 1] = "Email";
    /** Sms - SMS confirmation required */
    ConfirmationMethod[ConfirmationMethod["Sms"] = 2] = "Sms";
    /** ConnectedDevice - Confirmation from a connected device is required */
    ConfirmationMethod[ConfirmationMethod["ConnectedDevice"] = 3] = "ConnectedDevice";
    /** Other - Third-party method of confirmation is required */
    ConfirmationMethod[ConfirmationMethod["Other"] = 10] = "Other";
    ConfirmationMethod[ConfirmationMethod["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfirmationMethod = exports.ConfirmationMethod || (exports.ConfirmationMethod = {}));
function confirmationMethodFromJSON(object) {
    switch (object) {
        case 0:
        case "None":
            return ConfirmationMethod.None;
        case 1:
        case "Email":
            return ConfirmationMethod.Email;
        case 2:
        case "Sms":
            return ConfirmationMethod.Sms;
        case 3:
        case "ConnectedDevice":
            return ConfirmationMethod.ConnectedDevice;
        case 10:
        case "Other":
            return ConfirmationMethod.Other;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConfirmationMethod.UNRECOGNIZED;
    }
}
exports.confirmationMethodFromJSON = confirmationMethodFromJSON;
function confirmationMethodToJSON(object) {
    switch (object) {
        case ConfirmationMethod.None:
            return "None";
        case ConfirmationMethod.Email:
            return "Email";
        case ConfirmationMethod.Sms:
            return "Sms";
        case ConfirmationMethod.ConnectedDevice:
            return "ConnectedDevice";
        case ConfirmationMethod.Other:
            return "Other";
        case ConfirmationMethod.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.confirmationMethodToJSON = confirmationMethodToJSON;
function createBaseSignInRequest() {
    return { details: undefined, invitationCode: "", ecosystemId: "" };
}
exports.SignInRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.details !== undefined) {
            exports.AccountDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
        }
        if (message.invitationCode !== "") {
            writer.uint32(18).string(message.invitationCode);
        }
        if (message.ecosystemId !== "") {
            writer.uint32(26).string(message.ecosystemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignInRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.details = exports.AccountDetails.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.invitationCode = reader.string();
                    break;
                case 3:
                    message.ecosystemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details)
                ? exports.AccountDetails.fromJSON(object.details)
                : undefined,
            invitationCode: isSet(object.invitationCode)
                ? String(object.invitationCode)
                : "",
            ecosystemId: isSet(object.ecosystemId) ? String(object.ecosystemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.details !== undefined &&
            (obj.details = message.details
                ? exports.AccountDetails.toJSON(message.details)
                : undefined);
        message.invitationCode !== undefined &&
            (obj.invitationCode = message.invitationCode);
        message.ecosystemId !== undefined &&
            (obj.ecosystemId = message.ecosystemId);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSignInRequest();
        message.details =
            object.details !== undefined && object.details !== null
                ? exports.AccountDetails.fromPartial(object.details)
                : undefined;
        message.invitationCode = (_a = object.invitationCode) !== null && _a !== void 0 ? _a : "";
        message.ecosystemId = (_b = object.ecosystemId) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseAccountDetails() {
    return { name: "", email: "", sms: "" };
}
exports.AccountDetails = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.email !== "") {
            writer.uint32(18).string(message.email);
        }
        if (message.sms !== "") {
            writer.uint32(26).string(message.sms);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.sms = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            email: isSet(object.email) ? String(object.email) : "",
            sms: isSet(object.sms) ? String(object.sms) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.email !== undefined && (obj.email = message.email);
        message.sms !== undefined && (obj.sms = message.sms);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAccountDetails();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.email = (_b = object.email) !== null && _b !== void 0 ? _b : "";
        message.sms = (_c = object.sms) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseSignInResponse() {
    return { confirmationMethod: 0, profile: undefined };
}
exports.SignInResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.confirmationMethod !== 0) {
            writer.uint32(24).int32(message.confirmationMethod);
        }
        if (message.profile !== undefined) {
            exports.AccountProfile.encode(message.profile, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignInResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.confirmationMethod = reader.int32();
                    break;
                case 4:
                    message.profile = exports.AccountProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            confirmationMethod: isSet(object.confirmationMethod)
                ? confirmationMethodFromJSON(object.confirmationMethod)
                : 0,
            profile: isSet(object.profile)
                ? exports.AccountProfile.fromJSON(object.profile)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.confirmationMethod !== undefined &&
            (obj.confirmationMethod = confirmationMethodToJSON(message.confirmationMethod));
        message.profile !== undefined &&
            (obj.profile = message.profile
                ? exports.AccountProfile.toJSON(message.profile)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSignInResponse();
        message.confirmationMethod = (_a = object.confirmationMethod) !== null && _a !== void 0 ? _a : 0;
        message.profile =
            object.profile !== undefined && object.profile !== null
                ? exports.AccountProfile.fromPartial(object.profile)
                : undefined;
        return message;
    },
};
function createBaseAccountProfile() {
    return {
        profileType: "",
        authData: new Uint8Array(),
        authToken: new Uint8Array(),
        protection: undefined,
    };
}
exports.AccountProfile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.profileType !== "") {
            writer.uint32(10).string(message.profileType);
        }
        if (message.authData.length !== 0) {
            writer.uint32(18).bytes(message.authData);
        }
        if (message.authToken.length !== 0) {
            writer.uint32(26).bytes(message.authToken);
        }
        if (message.protection !== undefined) {
            exports.TokenProtection.encode(message.protection, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountProfile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profileType = reader.string();
                    break;
                case 2:
                    message.authData = reader.bytes();
                    break;
                case 3:
                    message.authToken = reader.bytes();
                    break;
                case 4:
                    message.protection = exports.TokenProtection.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            profileType: isSet(object.profileType) ? String(object.profileType) : "",
            authData: isSet(object.authData)
                ? bytesFromBase64(object.authData)
                : new Uint8Array(),
            authToken: isSet(object.authToken)
                ? bytesFromBase64(object.authToken)
                : new Uint8Array(),
            protection: isSet(object.protection)
                ? exports.TokenProtection.fromJSON(object.protection)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.profileType !== undefined &&
            (obj.profileType = message.profileType);
        message.authData !== undefined &&
            (obj.authData = base64FromBytes(message.authData !== undefined ? message.authData : new Uint8Array()));
        message.authToken !== undefined &&
            (obj.authToken = base64FromBytes(message.authToken !== undefined ? message.authToken : new Uint8Array()));
        message.protection !== undefined &&
            (obj.protection = message.protection
                ? exports.TokenProtection.toJSON(message.protection)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAccountProfile();
        message.profileType = (_a = object.profileType) !== null && _a !== void 0 ? _a : "";
        message.authData = (_b = object.authData) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.authToken = (_c = object.authToken) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.protection =
            object.protection !== undefined && object.protection !== null
                ? exports.TokenProtection.fromPartial(object.protection)
                : undefined;
        return message;
    },
};
function createBaseTokenProtection() {
    return { enabled: false, method: 0 };
}
exports.TokenProtection = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enabled === true) {
            writer.uint32(8).bool(message.enabled);
        }
        if (message.method !== 0) {
            writer.uint32(16).int32(message.method);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenProtection();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,
            method: isSet(object.method)
                ? confirmationMethodFromJSON(object.method)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.enabled !== undefined && (obj.enabled = message.enabled);
        message.method !== undefined &&
            (obj.method = confirmationMethodToJSON(message.method));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTokenProtection();
        message.enabled = (_a = object.enabled) !== null && _a !== void 0 ? _a : false;
        message.method = (_b = object.method) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseAccountInfoRequest() {
    return {};
}
exports.AccountInfoRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseAccountInfoRequest();
        return message;
    },
};
function createBaseAccountInfoResponse() {
    return {
        details: undefined,
        ecosystems: [],
        walletId: "",
        deviceId: "",
        ecosystemId: "",
        publicDid: "",
        authorizedWebhooks: [],
    };
}
exports.AccountInfoResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.details !== undefined) {
            exports.AccountDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.ecosystems) {
            exports.AccountEcosystem.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.walletId !== "") {
            writer.uint32(26).string(message.walletId);
        }
        if (message.deviceId !== "") {
            writer.uint32(34).string(message.deviceId);
        }
        if (message.ecosystemId !== "") {
            writer.uint32(42).string(message.ecosystemId);
        }
        if (message.publicDid !== "") {
            writer.uint32(50).string(message.publicDid);
        }
        for (const v of message.authorizedWebhooks) {
            writer.uint32(58).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.details = exports.AccountDetails.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ecosystems.push(exports.AccountEcosystem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.walletId = reader.string();
                    break;
                case 4:
                    message.deviceId = reader.string();
                    break;
                case 5:
                    message.ecosystemId = reader.string();
                    break;
                case 6:
                    message.publicDid = reader.string();
                    break;
                case 7:
                    message.authorizedWebhooks.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details)
                ? exports.AccountDetails.fromJSON(object.details)
                : undefined,
            ecosystems: Array.isArray(object === null || object === void 0 ? void 0 : object.ecosystems)
                ? object.ecosystems.map((e) => exports.AccountEcosystem.fromJSON(e))
                : [],
            walletId: isSet(object.walletId) ? String(object.walletId) : "",
            deviceId: isSet(object.deviceId) ? String(object.deviceId) : "",
            ecosystemId: isSet(object.ecosystemId) ? String(object.ecosystemId) : "",
            publicDid: isSet(object.publicDid) ? String(object.publicDid) : "",
            authorizedWebhooks: Array.isArray(object === null || object === void 0 ? void 0 : object.authorizedWebhooks)
                ? object.authorizedWebhooks.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.details !== undefined &&
            (obj.details = message.details
                ? exports.AccountDetails.toJSON(message.details)
                : undefined);
        if (message.ecosystems) {
            obj.ecosystems = message.ecosystems.map((e) => e ? exports.AccountEcosystem.toJSON(e) : undefined);
        }
        else {
            obj.ecosystems = [];
        }
        message.walletId !== undefined && (obj.walletId = message.walletId);
        message.deviceId !== undefined && (obj.deviceId = message.deviceId);
        message.ecosystemId !== undefined &&
            (obj.ecosystemId = message.ecosystemId);
        message.publicDid !== undefined && (obj.publicDid = message.publicDid);
        if (message.authorizedWebhooks) {
            obj.authorizedWebhooks = message.authorizedWebhooks.map((e) => e);
        }
        else {
            obj.authorizedWebhooks = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseAccountInfoResponse();
        message.details =
            object.details !== undefined && object.details !== null
                ? exports.AccountDetails.fromPartial(object.details)
                : undefined;
        message.ecosystems =
            ((_a = object.ecosystems) === null || _a === void 0 ? void 0 : _a.map((e) => exports.AccountEcosystem.fromPartial(e))) || [];
        message.walletId = (_b = object.walletId) !== null && _b !== void 0 ? _b : "";
        message.deviceId = (_c = object.deviceId) !== null && _c !== void 0 ? _c : "";
        message.ecosystemId = (_d = object.ecosystemId) !== null && _d !== void 0 ? _d : "";
        message.publicDid = (_e = object.publicDid) !== null && _e !== void 0 ? _e : "";
        message.authorizedWebhooks = ((_f = object.authorizedWebhooks) === null || _f === void 0 ? void 0 : _f.map((e) => e)) || [];
        return message;
    },
};
function createBaseListDevicesRequest() {
    return {};
}
exports.ListDevicesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListDevicesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseListDevicesRequest();
        return message;
    },
};
function createBaseListDevicesResponse() {
    return {};
}
exports.ListDevicesResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListDevicesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseListDevicesResponse();
        return message;
    },
};
function createBaseRevokeDeviceRequest() {
    return {};
}
exports.RevokeDeviceRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeDeviceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRevokeDeviceRequest();
        return message;
    },
};
function createBaseRevokeDeviceResponse() {
    return {};
}
exports.RevokeDeviceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeDeviceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRevokeDeviceResponse();
        return message;
    },
};
function createBaseAccountEcosystem() {
    return { id: "", name: "", description: "", uri: "" };
}
exports.AccountEcosystem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.uri !== "") {
            writer.uint32(34).string(message.uri);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountEcosystem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.uri = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            uri: isSet(object.uri) ? String(object.uri) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined &&
            (obj.description = message.description);
        message.uri !== undefined && (obj.uri = message.uri);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseAccountEcosystem();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.description = (_c = object.description) !== null && _c !== void 0 ? _c : "";
        message.uri = (_d = object.uri) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseLoginRequest() {
    return { email: "", invitationCode: "", ecosystemId: "" };
}
exports.LoginRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.email !== "") {
            writer.uint32(10).string(message.email);
        }
        if (message.invitationCode !== "") {
            writer.uint32(18).string(message.invitationCode);
        }
        if (message.ecosystemId !== "") {
            writer.uint32(26).string(message.ecosystemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoginRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.invitationCode = reader.string();
                    break;
                case 3:
                    message.ecosystemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            email: isSet(object.email) ? String(object.email) : "",
            invitationCode: isSet(object.invitationCode)
                ? String(object.invitationCode)
                : "",
            ecosystemId: isSet(object.ecosystemId) ? String(object.ecosystemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.email !== undefined && (obj.email = message.email);
        message.invitationCode !== undefined &&
            (obj.invitationCode = message.invitationCode);
        message.ecosystemId !== undefined &&
            (obj.ecosystemId = message.ecosystemId);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseLoginRequest();
        message.email = (_a = object.email) !== null && _a !== void 0 ? _a : "";
        message.invitationCode = (_b = object.invitationCode) !== null && _b !== void 0 ? _b : "";
        message.ecosystemId = (_c = object.ecosystemId) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseLoginResponse() {
    return { challenge: undefined, profile: undefined };
}
exports.LoginResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.challenge !== undefined) {
            writer.uint32(10).bytes(message.challenge);
        }
        if (message.profile !== undefined) {
            exports.AccountProfile.encode(message.profile, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoginResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challenge = reader.bytes();
                    break;
                case 2:
                    message.profile = exports.AccountProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challenge: isSet(object.challenge)
                ? bytesFromBase64(object.challenge)
                : undefined,
            profile: isSet(object.profile)
                ? exports.AccountProfile.fromJSON(object.profile)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.challenge !== undefined &&
            (obj.challenge =
                message.challenge !== undefined
                    ? base64FromBytes(message.challenge)
                    : undefined);
        message.profile !== undefined &&
            (obj.profile = message.profile
                ? exports.AccountProfile.toJSON(message.profile)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseLoginResponse();
        message.challenge = (_a = object.challenge) !== null && _a !== void 0 ? _a : undefined;
        message.profile =
            object.profile !== undefined && object.profile !== null
                ? exports.AccountProfile.fromPartial(object.profile)
                : undefined;
        return message;
    },
};
function createBaseLoginConfirmRequest() {
    return {
        challenge: new Uint8Array(),
        confirmationCodeHashed: new Uint8Array(),
    };
}
exports.LoginConfirmRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.challenge.length !== 0) {
            writer.uint32(10).bytes(message.challenge);
        }
        if (message.confirmationCodeHashed.length !== 0) {
            writer.uint32(18).bytes(message.confirmationCodeHashed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoginConfirmRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challenge = reader.bytes();
                    break;
                case 2:
                    message.confirmationCodeHashed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challenge: isSet(object.challenge)
                ? bytesFromBase64(object.challenge)
                : new Uint8Array(),
            confirmationCodeHashed: isSet(object.confirmationCodeHashed)
                ? bytesFromBase64(object.confirmationCodeHashed)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.challenge !== undefined &&
            (obj.challenge = base64FromBytes(message.challenge !== undefined ? message.challenge : new Uint8Array()));
        message.confirmationCodeHashed !== undefined &&
            (obj.confirmationCodeHashed = base64FromBytes(message.confirmationCodeHashed !== undefined
                ? message.confirmationCodeHashed
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLoginConfirmRequest();
        message.challenge = (_a = object.challenge) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.confirmationCodeHashed =
            (_b = object.confirmationCodeHashed) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseLoginConfirmResponse() {
    return { profile: undefined };
}
exports.LoginConfirmResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.profile !== undefined) {
            exports.AccountProfile.encode(message.profile, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoginConfirmResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profile = exports.AccountProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            profile: isSet(object.profile)
                ? exports.AccountProfile.fromJSON(object.profile)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.profile !== undefined &&
            (obj.profile = message.profile
                ? exports.AccountProfile.toJSON(message.profile)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseLoginConfirmResponse();
        message.profile =
            object.profile !== undefined && object.profile !== null
                ? exports.AccountProfile.fromPartial(object.profile)
                : undefined;
        return message;
    },
};
function createBaseAuthorizeWebhookRequest() {
    return { events: [] };
}
exports.AuthorizeWebhookRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthorizeWebhookRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.events.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            events: Array.isArray(object === null || object === void 0 ? void 0 : object.events)
                ? object.events.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.events) {
            obj.events = message.events.map((e) => e);
        }
        else {
            obj.events = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAuthorizeWebhookRequest();
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
    },
};
function createBaseAuthorizeWebhookResponse() {
    return {};
}
exports.AuthorizeWebhookResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthorizeWebhookResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseAuthorizeWebhookResponse();
        return message;
    },
};
exports.AccountDefinition = {
    name: "Account",
    fullName: "services.account.v1.Account",
    methods: {
        /**
         * Sign in to an already existing account
         *
         * @deprecated
         */
        signIn: {
            name: "SignIn",
            requestType: exports.SignInRequest,
            requestStream: false,
            responseType: exports.SignInResponse,
            responseStream: false,
            options: {},
        },
        /** Begin login flow for specified account, creating one if it does not already exist */
        login: {
            name: "Login",
            requestType: exports.LoginRequest,
            requestStream: false,
            responseType: exports.LoginResponse,
            responseStream: false,
            options: {},
        },
        /** Finalize login flow with two-factor confirmation code */
        loginConfirm: {
            name: "LoginConfirm",
            requestType: exports.LoginConfirmRequest,
            requestStream: false,
            responseType: exports.LoginConfirmResponse,
            responseStream: false,
            options: {},
        },
        /** Get account information */
        info: {
            name: "Info",
            requestType: exports.AccountInfoRequest,
            requestStream: false,
            responseType: exports.AccountInfoResponse,
            responseStream: false,
            options: {},
        },
        /** List all connected devices */
        listDevices: {
            name: "ListDevices",
            requestType: exports.ListDevicesRequest,
            requestStream: false,
            responseType: exports.ListDevicesResponse,
            responseStream: false,
            options: {},
        },
        /** Revoke device access to the account's cloud wallet */
        revokeDevice: {
            name: "RevokeDevice",
            requestType: exports.RevokeDeviceRequest,
            requestStream: false,
            responseType: exports.RevokeDeviceResponse,
            responseStream: false,
            options: {},
        },
        /** Authorize Ecosystem to receive webhook events */
        authorizeWebhook: {
            name: "AuthorizeWebhook",
            requestType: exports.AuthorizeWebhookRequest,
            requestStream: false,
            responseType: exports.AuthorizeWebhookResponse,
            responseStream: false,
            options: {},
        },
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=account.js.map