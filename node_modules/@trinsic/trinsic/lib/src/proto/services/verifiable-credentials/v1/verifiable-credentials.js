"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifiableCredentialDefinition = exports.CheckStatusResponse = exports.CheckStatusRequest = exports.UpdateStatusResponse = exports.UpdateStatusRequest = exports.SendResponse = exports.SendRequest = exports.ValidationMessage = exports.VerifyProofResponse_ValidationResultsEntry = exports.VerifyProofResponse = exports.VerifyProofRequest = exports.CreateProofResponse = exports.CreateProofRequest = exports.IssueFromTemplateResponse = exports.IssueFromTemplateRequest = exports.IssueResponse = exports.IssueRequest = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
function createBaseIssueRequest() {
    return { documentJson: "" };
}
exports.IssueRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.documentJson !== "") {
            writer.uint32(10).string(message.documentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIssueRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.documentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            documentJson: isSet(object.documentJson)
                ? String(object.documentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.documentJson !== undefined &&
            (obj.documentJson = message.documentJson);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseIssueRequest();
        message.documentJson = (_a = object.documentJson) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseIssueResponse() {
    return { signedDocumentJson: "" };
}
exports.IssueResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedDocumentJson !== "") {
            writer.uint32(10).string(message.signedDocumentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIssueResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signedDocumentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signedDocumentJson: isSet(object.signedDocumentJson)
                ? String(object.signedDocumentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.signedDocumentJson !== undefined &&
            (obj.signedDocumentJson = message.signedDocumentJson);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseIssueResponse();
        message.signedDocumentJson = (_a = object.signedDocumentJson) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseIssueFromTemplateRequest() {
    return { templateId: "", valuesJson: "", frameworkId: "" };
}
exports.IssueFromTemplateRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.templateId !== "") {
            writer.uint32(10).string(message.templateId);
        }
        if (message.valuesJson !== "") {
            writer.uint32(18).string(message.valuesJson);
        }
        if (message.frameworkId !== "") {
            writer.uint32(26).string(message.frameworkId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIssueFromTemplateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.templateId = reader.string();
                    break;
                case 2:
                    message.valuesJson = reader.string();
                    break;
                case 3:
                    message.frameworkId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            templateId: isSet(object.templateId) ? String(object.templateId) : "",
            valuesJson: isSet(object.valuesJson) ? String(object.valuesJson) : "",
            frameworkId: isSet(object.frameworkId) ? String(object.frameworkId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.templateId !== undefined && (obj.templateId = message.templateId);
        message.valuesJson !== undefined && (obj.valuesJson = message.valuesJson);
        message.frameworkId !== undefined &&
            (obj.frameworkId = message.frameworkId);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseIssueFromTemplateRequest();
        message.templateId = (_a = object.templateId) !== null && _a !== void 0 ? _a : "";
        message.valuesJson = (_b = object.valuesJson) !== null && _b !== void 0 ? _b : "";
        message.frameworkId = (_c = object.frameworkId) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseIssueFromTemplateResponse() {
    return { documentJson: "" };
}
exports.IssueFromTemplateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.documentJson !== "") {
            writer.uint32(10).string(message.documentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIssueFromTemplateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.documentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            documentJson: isSet(object.documentJson)
                ? String(object.documentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.documentJson !== undefined &&
            (obj.documentJson = message.documentJson);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseIssueFromTemplateResponse();
        message.documentJson = (_a = object.documentJson) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseCreateProofRequest() {
    return { revealDocumentJson: "", itemId: undefined, documentJson: undefined };
}
exports.CreateProofRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.revealDocumentJson !== "") {
            writer.uint32(10).string(message.revealDocumentJson);
        }
        if (message.itemId !== undefined) {
            writer.uint32(18).string(message.itemId);
        }
        if (message.documentJson !== undefined) {
            writer.uint32(26).string(message.documentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateProofRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.revealDocumentJson = reader.string();
                    break;
                case 2:
                    message.itemId = reader.string();
                    break;
                case 3:
                    message.documentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            revealDocumentJson: isSet(object.revealDocumentJson)
                ? String(object.revealDocumentJson)
                : "",
            itemId: isSet(object.itemId) ? String(object.itemId) : undefined,
            documentJson: isSet(object.documentJson)
                ? String(object.documentJson)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.revealDocumentJson !== undefined &&
            (obj.revealDocumentJson = message.revealDocumentJson);
        message.itemId !== undefined && (obj.itemId = message.itemId);
        message.documentJson !== undefined &&
            (obj.documentJson = message.documentJson);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCreateProofRequest();
        message.revealDocumentJson = (_a = object.revealDocumentJson) !== null && _a !== void 0 ? _a : "";
        message.itemId = (_b = object.itemId) !== null && _b !== void 0 ? _b : undefined;
        message.documentJson = (_c = object.documentJson) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseCreateProofResponse() {
    return { proofDocumentJson: "" };
}
exports.CreateProofResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proofDocumentJson !== "") {
            writer.uint32(10).string(message.proofDocumentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateProofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.proofDocumentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            proofDocumentJson: isSet(object.proofDocumentJson)
                ? String(object.proofDocumentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.proofDocumentJson !== undefined &&
            (obj.proofDocumentJson = message.proofDocumentJson);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCreateProofResponse();
        message.proofDocumentJson = (_a = object.proofDocumentJson) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseVerifyProofRequest() {
    return { proofDocumentJson: "" };
}
exports.VerifyProofRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proofDocumentJson !== "") {
            writer.uint32(10).string(message.proofDocumentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyProofRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.proofDocumentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            proofDocumentJson: isSet(object.proofDocumentJson)
                ? String(object.proofDocumentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.proofDocumentJson !== undefined &&
            (obj.proofDocumentJson = message.proofDocumentJson);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifyProofRequest();
        message.proofDocumentJson = (_a = object.proofDocumentJson) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseVerifyProofResponse() {
    return { isValid: false, validationMessages: [], validationResults: {} };
}
exports.VerifyProofResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isValid === true) {
            writer.uint32(8).bool(message.isValid);
        }
        for (const v of message.validationMessages) {
            writer.uint32(18).string(v);
        }
        Object.entries(message.validationResults).forEach(([key, value]) => {
            exports.VerifyProofResponse_ValidationResultsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyProofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isValid = reader.bool();
                    break;
                case 2:
                    message.validationMessages.push(reader.string());
                    break;
                case 3:
                    const entry3 = exports.VerifyProofResponse_ValidationResultsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.validationResults[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,
            validationMessages: Array.isArray(object === null || object === void 0 ? void 0 : object.validationMessages)
                ? object.validationMessages.map((e) => String(e))
                : [],
            validationResults: isObject(object.validationResults)
                ? Object.entries(object.validationResults).reduce((acc, [key, value]) => {
                    acc[key] = exports.ValidationMessage.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.isValid !== undefined && (obj.isValid = message.isValid);
        if (message.validationMessages) {
            obj.validationMessages = message.validationMessages.map((e) => e);
        }
        else {
            obj.validationMessages = [];
        }
        obj.validationResults = {};
        if (message.validationResults) {
            Object.entries(message.validationResults).forEach(([k, v]) => {
                obj.validationResults[k] = exports.ValidationMessage.toJSON(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseVerifyProofResponse();
        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;
        message.validationMessages = ((_b = object.validationMessages) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.validationResults = Object.entries((_c = object.validationResults) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.ValidationMessage.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseVerifyProofResponse_ValidationResultsEntry() {
    return { key: "", value: undefined };
}
exports.VerifyProofResponse_ValidationResultsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.ValidationMessage.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyProofResponse_ValidationResultsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.ValidationMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value)
                ? exports.ValidationMessage.fromJSON(object.value)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value
                ? exports.ValidationMessage.toJSON(message.value)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVerifyProofResponse_ValidationResultsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value =
            object.value !== undefined && object.value !== null
                ? exports.ValidationMessage.fromPartial(object.value)
                : undefined;
        return message;
    },
};
function createBaseValidationMessage() {
    return { isValid: false, messages: [] };
}
exports.ValidationMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isValid === true) {
            writer.uint32(8).bool(message.isValid);
        }
        for (const v of message.messages) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidationMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isValid = reader.bool();
                    break;
                case 2:
                    message.messages.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,
            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)
                ? object.messages.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.isValid !== undefined && (obj.isValid = message.isValid);
        if (message.messages) {
            obj.messages = message.messages.map((e) => e);
        }
        else {
            obj.messages = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseValidationMessage();
        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;
        message.messages = ((_b = object.messages) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseSendRequest() {
    return {
        email: undefined,
        didUri: undefined,
        didcommInvitationJson: undefined,
        documentJson: "",
    };
}
exports.SendRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.email !== undefined) {
            writer.uint32(10).string(message.email);
        }
        if (message.didUri !== undefined) {
            writer.uint32(18).string(message.didUri);
        }
        if (message.didcommInvitationJson !== undefined) {
            writer.uint32(26).string(message.didcommInvitationJson);
        }
        if (message.documentJson !== "") {
            writer.uint32(802).string(message.documentJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.didUri = reader.string();
                    break;
                case 3:
                    message.didcommInvitationJson = reader.string();
                    break;
                case 100:
                    message.documentJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            email: isSet(object.email) ? String(object.email) : undefined,
            didUri: isSet(object.didUri) ? String(object.didUri) : undefined,
            didcommInvitationJson: isSet(object.didcommInvitationJson)
                ? String(object.didcommInvitationJson)
                : undefined,
            documentJson: isSet(object.documentJson)
                ? String(object.documentJson)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.email !== undefined && (obj.email = message.email);
        message.didUri !== undefined && (obj.didUri = message.didUri);
        message.didcommInvitationJson !== undefined &&
            (obj.didcommInvitationJson = message.didcommInvitationJson);
        message.documentJson !== undefined &&
            (obj.documentJson = message.documentJson);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSendRequest();
        message.email = (_a = object.email) !== null && _a !== void 0 ? _a : undefined;
        message.didUri = (_b = object.didUri) !== null && _b !== void 0 ? _b : undefined;
        message.didcommInvitationJson = (_c = object.didcommInvitationJson) !== null && _c !== void 0 ? _c : undefined;
        message.documentJson = (_d = object.documentJson) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseSendResponse() {
    return {};
}
exports.SendResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseSendResponse();
        return message;
    },
};
function createBaseUpdateStatusRequest() {
    return { credentialStatusId: "", revoked: false };
}
exports.UpdateStatusRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.credentialStatusId !== "") {
            writer.uint32(10).string(message.credentialStatusId);
        }
        if (message.revoked === true) {
            writer.uint32(16).bool(message.revoked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateStatusRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.credentialStatusId = reader.string();
                    break;
                case 2:
                    message.revoked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            credentialStatusId: isSet(object.credentialStatusId)
                ? String(object.credentialStatusId)
                : "",
            revoked: isSet(object.revoked) ? Boolean(object.revoked) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.credentialStatusId !== undefined &&
            (obj.credentialStatusId = message.credentialStatusId);
        message.revoked !== undefined && (obj.revoked = message.revoked);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateStatusRequest();
        message.credentialStatusId = (_a = object.credentialStatusId) !== null && _a !== void 0 ? _a : "";
        message.revoked = (_b = object.revoked) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseUpdateStatusResponse() {
    return {};
}
exports.UpdateStatusResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseUpdateStatusResponse();
        return message;
    },
};
function createBaseCheckStatusRequest() {
    return { credentialStatusId: "" };
}
exports.CheckStatusRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.credentialStatusId !== "") {
            writer.uint32(10).string(message.credentialStatusId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckStatusRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.credentialStatusId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            credentialStatusId: isSet(object.credentialStatusId)
                ? String(object.credentialStatusId)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.credentialStatusId !== undefined &&
            (obj.credentialStatusId = message.credentialStatusId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCheckStatusRequest();
        message.credentialStatusId = (_a = object.credentialStatusId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseCheckStatusResponse() {
    return { revoked: false };
}
exports.CheckStatusResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.revoked === true) {
            writer.uint32(8).bool(message.revoked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.revoked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            revoked: isSet(object.revoked) ? Boolean(object.revoked) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.revoked !== undefined && (obj.revoked = message.revoked);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseCheckStatusResponse();
        message.revoked = (_a = object.revoked) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
exports.VerifiableCredentialDefinition = {
    name: "VerifiableCredential",
    fullName: "services.verifiablecredentials.v1.VerifiableCredential",
    methods: {
        /**
         * Sign and issue a verifiable credential from a submitted document.
         * The document must be a valid JSON-LD document.
         */
        issue: {
            name: "Issue",
            requestType: exports.IssueRequest,
            requestStream: false,
            responseType: exports.IssueResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Sign and issue a verifiable credential from a pre-defined template.
         * This process will also add schema validation and
         * revocation registry values to the credential.
         */
        issueFromTemplate: {
            name: "IssueFromTemplate",
            requestType: exports.IssueFromTemplateRequest,
            requestStream: false,
            responseType: exports.IssueFromTemplateResponse,
            responseStream: false,
            options: {},
        },
        /** Check credential status in the revocation registry */
        checkStatus: {
            name: "CheckStatus",
            requestType: exports.CheckStatusRequest,
            requestStream: false,
            responseType: exports.CheckStatusResponse,
            responseStream: false,
            options: {},
        },
        /** Update credential status by setting the revocation value */
        updateStatus: {
            name: "UpdateStatus",
            requestType: exports.UpdateStatusRequest,
            requestStream: false,
            responseType: exports.UpdateStatusResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Create a proof from a signed document that is a valid
         * verifiable credential and contains a signature from which a proof can be derived.
         */
        createProof: {
            name: "CreateProof",
            requestType: exports.CreateProofRequest,
            requestStream: false,
            responseType: exports.CreateProofResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Verifies a proof by checking the signature value, and if possible schema validation,
         * revocation status, and issuer status against a trust registry
         */
        verifyProof: {
            name: "VerifyProof",
            requestType: exports.VerifyProofRequest,
            requestStream: false,
            responseType: exports.VerifyProofResponse,
            responseStream: false,
            options: {},
        },
        /** Sends a document directly to a user's email within the given ecosystem */
        send: {
            name: "Send",
            requestType: exports.SendRequest,
            requestStream: false,
            responseType: exports.SendResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=verifiable-credentials.js.map