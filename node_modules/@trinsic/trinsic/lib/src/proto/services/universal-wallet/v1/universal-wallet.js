"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniversalWalletDefinition = exports.DeleteItemResponse = exports.DeleteItemRequest = exports.InsertItemResponse = exports.InsertItemRequest = exports.UpdateItemResponse = exports.UpdateItemRequest = exports.GetItemResponse = exports.GetItemRequest = exports.SearchResponse = exports.SearchRequest = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
function createBaseSearchRequest() {
    return { query: "", continuationToken: "" };
}
exports.SearchRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.query !== "") {
            writer.uint32(10).string(message.query);
        }
        if (message.continuationToken !== "") {
            writer.uint32(18).string(message.continuationToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                case 2:
                    message.continuationToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            query: isSet(object.query) ? String(object.query) : "",
            continuationToken: isSet(object.continuationToken)
                ? String(object.continuationToken)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.query !== undefined && (obj.query = message.query);
        message.continuationToken !== undefined &&
            (obj.continuationToken = message.continuationToken);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSearchRequest();
        message.query = (_a = object.query) !== null && _a !== void 0 ? _a : "";
        message.continuationToken = (_b = object.continuationToken) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseSearchResponse() {
    return { items: [], hasMore: false, continuationToken: "" };
}
exports.SearchResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.items) {
            writer.uint32(10).string(v);
        }
        if (message.hasMore === true) {
            writer.uint32(16).bool(message.hasMore);
        }
        if (message.continuationToken !== "") {
            writer.uint32(34).string(message.continuationToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.items.push(reader.string());
                    break;
                case 2:
                    message.hasMore = reader.bool();
                    break;
                case 4:
                    message.continuationToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            items: Array.isArray(object === null || object === void 0 ? void 0 : object.items)
                ? object.items.map((e) => String(e))
                : [],
            hasMore: isSet(object.hasMore) ? Boolean(object.hasMore) : false,
            continuationToken: isSet(object.continuationToken)
                ? String(object.continuationToken)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.items) {
            obj.items = message.items.map((e) => e);
        }
        else {
            obj.items = [];
        }
        message.hasMore !== undefined && (obj.hasMore = message.hasMore);
        message.continuationToken !== undefined &&
            (obj.continuationToken = message.continuationToken);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSearchResponse();
        message.items = ((_a = object.items) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.hasMore = (_b = object.hasMore) !== null && _b !== void 0 ? _b : false;
        message.continuationToken = (_c = object.continuationToken) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseGetItemRequest() {
    return { itemId: "" };
}
exports.GetItemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetItemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemId: isSet(object.itemId) ? String(object.itemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemId !== undefined && (obj.itemId = message.itemId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetItemRequest();
        message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetItemResponse() {
    return { itemJson: "", itemType: "" };
}
exports.GetItemResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemJson !== "") {
            writer.uint32(10).string(message.itemJson);
        }
        if (message.itemType !== "") {
            writer.uint32(18).string(message.itemType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetItemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemJson = reader.string();
                    break;
                case 2:
                    message.itemType = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemJson: isSet(object.itemJson) ? String(object.itemJson) : "",
            itemType: isSet(object.itemType) ? String(object.itemType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemJson !== undefined && (obj.itemJson = message.itemJson);
        message.itemType !== undefined && (obj.itemType = message.itemType);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetItemResponse();
        message.itemJson = (_a = object.itemJson) !== null && _a !== void 0 ? _a : "";
        message.itemType = (_b = object.itemType) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseUpdateItemRequest() {
    return { itemId: "", itemType: "" };
}
exports.UpdateItemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.itemType !== "") {
            writer.uint32(18).string(message.itemType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateItemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.itemType = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemId: isSet(object.itemId) ? String(object.itemId) : "",
            itemType: isSet(object.itemType) ? String(object.itemType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemId !== undefined && (obj.itemId = message.itemId);
        message.itemType !== undefined && (obj.itemType = message.itemType);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateItemRequest();
        message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : "";
        message.itemType = (_b = object.itemType) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseUpdateItemResponse() {
    return {};
}
exports.UpdateItemResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateItemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseUpdateItemResponse();
        return message;
    },
};
function createBaseInsertItemRequest() {
    return { itemJson: "", itemType: "" };
}
exports.InsertItemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemJson !== "") {
            writer.uint32(10).string(message.itemJson);
        }
        if (message.itemType !== "") {
            writer.uint32(18).string(message.itemType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInsertItemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemJson = reader.string();
                    break;
                case 2:
                    message.itemType = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemJson: isSet(object.itemJson) ? String(object.itemJson) : "",
            itemType: isSet(object.itemType) ? String(object.itemType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemJson !== undefined && (obj.itemJson = message.itemJson);
        message.itemType !== undefined && (obj.itemType = message.itemType);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInsertItemRequest();
        message.itemJson = (_a = object.itemJson) !== null && _a !== void 0 ? _a : "";
        message.itemType = (_b = object.itemType) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseInsertItemResponse() {
    return { itemId: "" };
}
exports.InsertItemResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(18).string(message.itemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInsertItemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.itemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemId: isSet(object.itemId) ? String(object.itemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemId !== undefined && (obj.itemId = message.itemId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInsertItemResponse();
        message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteItemRequest() {
    return { itemId: "" };
}
exports.DeleteItemRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteItemRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemId: isSet(object.itemId) ? String(object.itemId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.itemId !== undefined && (obj.itemId = message.itemId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseDeleteItemRequest();
        message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteItemResponse() {
    return {};
}
exports.DeleteItemResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteItemResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseDeleteItemResponse();
        return message;
    },
};
exports.UniversalWalletDefinition = {
    name: "UniversalWallet",
    fullName: "services.universalwallet.v1.UniversalWallet",
    methods: {
        /** Retrieve an item from the wallet with a given item identifier */
        getItem: {
            name: "GetItem",
            requestType: exports.GetItemRequest,
            requestStream: false,
            responseType: exports.GetItemResponse,
            responseStream: false,
            options: {},
        },
        /** Search the wallet using a SQL syntax */
        search: {
            name: "Search",
            requestType: exports.SearchRequest,
            requestStream: false,
            responseType: exports.SearchResponse,
            responseStream: false,
            options: {},
        },
        /** Insert an item into the wallet */
        insertItem: {
            name: "InsertItem",
            requestType: exports.InsertItemRequest,
            requestStream: false,
            responseType: exports.InsertItemResponse,
            responseStream: false,
            options: {},
        },
        /** Update an item in the wallet */
        updateItem: {
            name: "UpdateItem",
            requestType: exports.UpdateItemRequest,
            requestStream: false,
            responseType: exports.UpdateItemResponse,
            responseStream: false,
            options: {},
        },
        /** Delete an item from the wallet permanently */
        deleteItem: {
            name: "DeleteItem",
            requestType: exports.DeleteItemRequest,
            requestStream: false,
            responseType: exports.DeleteItemResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=universal-wallet.js.map